@=~
~p maximum_input_line_length = infinity
$Id: CompRepr.fw,v 1.1 2015/05/13 10:17:34 pfahler Exp $

-----------------------------------------------------------
CompRepr.fw:

An internal representation for computations is defined.
Symbol computations and rule computations are translated into
that representation and linked to the computation key by the 
property CompRepr.
Accumulated computations (+=) are collected by the property
CompReprList.

Inherited computations are copied into the rule context
and linked to the computation key.

The following  checks and transformations are made for 
rule computations:
- symbol positions for inherited attribute and chain accesses
- illegal use of void attributes
- substitution of abbreviations for rule names and functions
- GENTREE computations checked and dummies generated
- with clause in value CONSTITUENTS
- check of inherited terminal access
- value or void propagation for INCLUDING and CONSTITUENTS
- distinction of a CONSTITUENTS if it is inherited by
  rules such that they differ in the SHIELD symbol
- expansion of the RHS construct
  check for the existence of the RHS attributes
- handle rule attributes
- symbol positions for HEAD and TAIL
- HEAD and TAIL substituted
- INCLUDING X.a in an INH computation, that is inherited by
  a RULE X ::= ... is substituted by an attribute access X[0].a
- any plain bottom-up computation is turned into an assignment
  to an individually created rule attribute - required by ligaMe
-----------------------------------------------------------

~$~<Create representation~>==~{
ATTR repr: PExpr;

SYMBOL AG COMPUTE
  SYNT.GotOrigRepr = 
    CONSTITUENTS Compute.GotOrigRepr <- CONSTITUENTS PlainComp.repr;
  SYNT.GotInhRepr = InheritRepr ()
   <- (SYNT.GotOrigRepr, SYNT.GotInheritCompute,
       SYNT.GotInheritAccu);
  SYNT.GotCompChecked = CheckRuleComps ()
   <- (SYNT.GotInhRepr, SYNT.GotAllAttrProps,
       SYNT.GotRemoteEpxrIsErr);
END;

SYMBOL Compute COMPUTE
  SYNT.GotOrigRepr = 
    IF (THIS.isAccu,
       AccumulateExpr
          (THIS.Key, CONSTITUENT (AttrComp.repr, PlainComp.repr)),
       ResetCompRepr 
          (THIS.Key, CONSTITUENT (AttrComp.repr, PlainComp.repr)));
END;

SYMBOL AttrComp COMPUTE
  SYNT.repr =
    newAssign
      (CONSTITUENT DefAttr.repr,
       CONSTITUENT (ExpressionDep.repr, Loop.repr) 
         SHIELD (ExpressionDep, Loop),
       COORDREF);
END;

SYMBOL PlainComp: BUAssignAttr: DefTableKey;
SYMBOL PlainComp COMPUTE
  SYNT.BUAssignAttr =
    IF (INCLUDING Compute.IsBottomUp,
      CreateBUAssignAttr
         (INCLUDING Context.Key, 
          GetAttribute (KeyOf (SYNT.Bind), NoKey),
	  COORDREF) 
         <- INCLUDING AG.GotAttrScope,
      NoKey);

  SYNT.repr = 
    IF (INCLUDING Compute.IsBottomUp,
      TurnPlainBUIntoAssign
        (INCLUDING Context.Key <- INCLUDING AG.GotAttrScope,
	 SYNT.BUAssignAttr,
         CONSTITUENT (ExpressionDep.repr, Loop.repr) 
           SHIELD (ExpressionDep, Loop),
         COORDREF),
      CONSTITUENT (ExpressionDep.repr, Loop.repr) 
        SHIELD (ExpressionDep, Loop));
END;

RULE: Loop ::= 'UNTIL' ExpressionDep 'ITERATE' Attr '=' ExpressionDep
COMPUTE
  Loop.repr = 
    newLoop
      (ExpressionDep[1].repr,
       Attr.repr,
       ExpressionDep[2].repr,
       COORDREF);
END;

RULE: DefAttr ::= Attr COMPUTE
  DefAttr.repr = Attr.repr;
END;

RULE: ExpressionDep ::= Expression COMPUTE
  ExpressionDep.repr = Expression.repr;
END;

RULE: ExpressionDep ::= Expression DepClause COMPUTE
  ExpressionDep.repr = 
    newDepend
      (Expression.repr, DepClause.PExprList, COORDREF);
END;

SYMBOL DepClause INHERITS PExprListRoot END;
SYMBOL DepAttr INHERITS PExprListElem COMPUTE
  SYNT.PExprElem =
    CONSTITUENT (RemoteExpression.repr, Attr.repr, RhsAttrs.repr);
END;

RULE: Expression ::= Identifier '(' ParamsOpt ')' COMPUTE
  Expression.repr = 
    newCall (Identifier, ParamsOpt.PExprList, COORDREF);
END;
SYMBOL ParamsOpt INHERITS PExprListRoot END;
SYMBOL Param INHERITS PExprListElem COMPUTE
  SYNT.PExprElem = CONSTITUENT ExpressionDep.repr;
END;

RULE: Expression ::= Attr COMPUTE
  Expression.repr = Attr.repr;
END;
RULE: Expression ::= RhsAttrs COMPUTE
  Expression.repr = RhsAttrs.repr;
END;
RULE: Expression ::= RemoteExpression COMPUTE
  Expression.repr = RemoteExpression.repr;
END;
RULE: Expression ::= SymbolRef COMPUTE
  Expression.repr = SymbolRef.repr;
END;
RULE: Expression ::= P_String COMPUTE
  Expression.repr = newChrValue (P_String, COORDREF);
END;
RULE: Expression ::= C_String COMPUTE
  Expression.repr = newStrValue (C_String, COORDREF);
END;
RULE: Expression ::= C_Float COMPUTE
  Expression.repr = newFltValue (C_Float, COORDREF);
END;
RULE: Expression ::= C_Integer COMPUTE
  Expression.repr = newIntValue (C_Integer, COORDREF);
END;

SYMBOL RemoteExpression COMPUTE
  SYNT.repr =
    IF (GetIsIncluding (THIS.RemoteKey, 0),
       newIncluding (THIS.RemoteKey, COORDREF),
    IF (GetIsConstituent (THIS.RemoteKey, 0),
       newConstituent (THIS.RemoteKey, THIS.SubtreeNo, COORDREF),
    IF (GetIsConstituents (THIS.RemoteKey, 0),
       newConstituents (THIS.RemoteKey, THIS.SubtreeNo, COORDREF),
       wrongExpr)));
END;

RULE: RhsAttrs ::= 'RHS' '.' Identifier COMPUTE
  RhsAttrs.repr = newRHS (Identifier, COORDREF);
END;

RULE: SymbolRef ::= SymbolId Index COMPUTE
  SymbolRef.repr = 
    IF (EQ (.ProdSymbol, NoProdSymbol),
       newName (SymbolId.Sym, COORDREF),
       newRuleTermAcc (SymbolRef.Pos, SymbolRef.Key, COORDREF));
END;
RULE: SymbolRef ::= 'TERM' Index COMPUTE
  SymbolRef.repr = newSymbTermAcc (Index.Value, COORDREF);
END;


RULE: Attr ::= SymOcc '.' AttrUseId COMPUTE
  Attr.repr = 
    IF (EQ (SymOcc.Key, HEADKey),
      newHeadAcc (AttrUseId.Key, COORDREF),
    IF (EQ (SymOcc.Key, TAILKey),
      newTailAcc (AttrUseId.Key, COORDREF),
    IF (INCLUDING Context.IsRule,
      newAttrAccRule
        (SymOcc.ProdSymbol,
         AttrUseId.Key,
         GetIsChain (AttrUseId.Key, 0), COORDREF),
      newAttrAccSymb
        (SymOcc.Key,
         AttrUseId.Key,
         GetIsChain (AttrUseId.Key, 0), COORDREF))))
    <- INCLUDING AG.GotChaindef;
END;

RULE: Attr ::= '.' AttrUseId COMPUTE
  Attr.repr = newRuleAttrAcc (AttrUseId.Key, COORDREF);
END;
~}


~O~<CompRepr.pdl~>~{
CompRepr: PExpr; "ExprRepr.h"
AllRuleComps: DefTableKeyList; "DefTableKeyList.h"
IsLoopInit: int;
IsGenTreeDummy: int;
InRemoteSet: int;
DerivableVisited: int;
~}

~O~<CompRepr.specs~>~{
$/Adt/LidoList.gnrc+instance=PExpr +referto=ExprRepr:inst
~}

~O~<ExprRepr.h~>==~{
#ifndef EXPRREPR_H
#define EXPRREPR_H

typedef struct TExpr *PExpr;

#endif
~}

~O~<ComputationRepr.h~>==~{
#ifndef COMPREPR_H
#define COMPREPR_H

#include "deftbl.h"
#include "err.h"
#include "PExprList.h"
#include "Prod.h"

typedef struct TExpr
  { int exprKind;
    CoordPtr coord;
    union
    { 
#define CallKind		1
      struct				/* call of functions, predefined or users */
        { int idn;			/* StringTable index of function name */
          PExprList params;
        } call;
#define NameKind		2
      int		name;
#define IntValueKind		3
      int		intValue;
#define StrValueKind		4
      int		strValue;
#define ChrValueKind		5
      int		chrValue;
#define FltValueKind		6
      int		fltValue;
#define AttrAccRuleKind		7
      struct				/* attribute access in rule context */
        { ProdSymbol  prodSymb;		/* symbol occurrence */
          DefTableKey attrKey;
          int         isChain;
        } attrAccRule;
#define RuleAttrAccKind		8
      struct				/* rule attribute access in rule context */
        { DefTableKey attrKey;
        } ruleAttrAcc;
#define AttrAccSymbKind		9
      struct				/* attribute access in symbol context */
        { DefTableKey symbKey;		/* symbol key or HEADKey or TAILKey */
          DefTableKey attrKey;
          int         isChain;
        } attrAccSymb;
#define IncludingKind		10
#define ConstituentKind		11
#define ConstituentsKind	12
      struct
        { DefTableKey	remKey;
          int subtree;                  /* for CONSTITUENT(S) only */
        } remote;
#define SymbTermAccKind		13
      int		symbTerm;
#define RuleTermAccKind		14
      struct				/* terminal access in rule context */
        { int symbNo;			/* position in production */
          DefTableKey symbKey;
        } ruleTerm;
#define RHSKind			15
      int		attrIdn;
#define HeadAccKind		16
#define TailAccKind		17
      DefTableKey	chnKey;
#define LoopKind		18
      struct
	{ PExpr		cond;
	  PExpr		attr;
	  PExpr		iter;
	} loop;
#define DependKind		19
      struct
	{ PExpr		ex;
	  PExprList	deps;
	} depend;
#define AssignKind		20
      struct
	{ PExpr		left;
	  PExpr		right;
	} assign;
#define ExprListKind		21
	PExprList	subList;
    } u;
#define wrongExprKind		22
  } _SExpr;

#define NULLPExpr ((PExpr)0)

#endif
~}

~O~<CompRepr.head~>==~{
#include "CompRepr.h"
#include "InheritRepr.h"
~}
~O~<CompRepr.h~>==~{
#include "args.h"

#include "ComputationRepr.h"

extern PExpr wrongExpr;

extern PExpr copyExpr FEARGS ((PExpr ex));

extern PExpr newCall FEARGS ((int name, PExprList params, CoordPtr coord));
extern PExpr newExprList FEARGS ((PExprList subList, CoordPtr coord));
extern PExpr newName FEARGS ((int name, CoordPtr coord));
extern PExpr newIntValue FEARGS ((int val, CoordPtr coord));
extern PExpr newStrValue FEARGS ((int val, CoordPtr coord));
extern PExpr newChrValue FEARGS ((int val, CoordPtr coord));
extern PExpr newFltValue FEARGS ((int val, CoordPtr coord));
extern PExpr newAttrAccRule 
   FEARGS ((ProdSymbol prodSymb, DefTableKey attrKey, int isChain, CoordPtr coord));
extern PExpr newRuleAttrAcc FEARGS ((DefTableKey attrKey, CoordPtr coord));
extern PExpr newAttrAccSymb
   FEARGS ((DefTableKey symbKey, DefTableKey attrKey, int isChain, CoordPtr coord));
extern PExpr newIncluding FEARGS ((DefTableKey inclKey, CoordPtr coord));
extern PExpr newConstituent FEARGS ((DefTableKey constKey, int subtree, CoordPtr coord));
extern PExpr newConstituents FEARGS ((DefTableKey constKey, int subtree, CoordPtr coord));
extern PExpr newSymbTermAcc FEARGS ((int index, CoordPtr coord));
extern PExpr newRuleTermAcc FEARGS ((int symbNo, DefTableKey termKey, CoordPtr coord));
extern PExpr newRHS FEARGS ((int attrIdn, CoordPtr coord));
extern PExpr newHeadAcc FEARGS ((DefTableKey chnKey, CoordPtr coord));
extern PExpr newTailAcc FEARGS ((DefTableKey chnKey, CoordPtr coord));
extern PExpr newLoop 
  FEARGS ((PExpr cond, PExpr attr, PExpr iter, CoordPtr coord));
extern PExpr newDepend FEARGS ((PExpr ex, PExprList deps, CoordPtr coord));
extern PExpr newAssign FEARGS ((PExpr left, PExpr right, CoordPtr coord));
~}

~O~<CompRepr.c~>==~{
#include "CompRepr.h"
#include "pdl_gen.h"
#include "DynSpace.h"
#include "csm.h"

#ifdef TEST
#define TEST
PExpr TESTEXPR =(PExpr)0;

void TESTIT(char *s)
{ printf ("TESTIT %s\n",s);
  if (!TESTEXPR) 
  { printf ("NULL\n"); return;}
  printf ("  kind %d line %d\n",
           TESTEXPR->exprKind, LineOf(*(TESTEXPR->coord)));
  if (TESTEXPR->exprKind == AttrAccRuleKind)
  { 
    printf ("  isChain    : %d\n", TESTEXPR->u.attrAccRule.isChain);
    printf ("  attrName   : %s\n", 
      StringTable (GetNameSym (TESTEXPR->u.attrAccRule.attrKey, 1)));
    printf ("  prodSymb no: %d\n", 
      TESTEXPR->u.attrAccRule.prodSymb->u.s.symbolpos);
  }
}
#endif

PExpr wrongExpr;

void *ExprSpace = (void*)0;

#if defined(__cplusplus) || defined(__STDC__)
PExpr allocExpr (CoordPtr coord)
#else
PExpr allocExpr (coord) CoordPtr coord;
#endif
{ PExpr res;
  if (!ExprSpace)
  { /* initialize: */
    ExprSpace = InitDynSpace ();
    wrongExpr = (PExpr) DynAlloc (ExprSpace, sizeof (_SExpr));
    wrongExpr->coord = NoPosition;
    wrongExpr->exprKind = wrongExprKind;
  }
  res = (PExpr) DynAlloc (ExprSpace, sizeof (_SExpr));
  res->coord = coord;
  return res;
}/* allocExpr */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newCall (int name, PExprList params, CoordPtr coord)
#else
PExpr newCall (name, params, coord) int name; PExprList params; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = CallKind;
  res->u.call.idn = name;
  res->u.call.params = params;
  return res;
}/* newCall */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newExprList (PExprList subList, CoordPtr coord)
#else
PExpr newExprList (subList, coord) PExprList subList; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = ExprListKind;
  res->u.subList = subList;
  return res;
}/* newExprList */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newDepend (PExpr ex, PExprList deps, CoordPtr coord)
#else
PExpr newDepend (ex, deps, coord) PExpr ex; PExprList deps; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = DependKind;
  res->u.depend.ex = ex;
  res->u.depend.deps = deps;
  return res;
}/* newDepend */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newAssign (PExpr left, PExpr right, CoordPtr coord)
#else
PExpr newAssign (left, right, coord) PExpr left; PExpr right; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = AssignKind;
  res->u.assign.left = left;
  res->u.assign.right = right;
  return res;
}/* newAssign */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newLoop (PExpr cond, PExpr attr, PExpr iter, CoordPtr coord)
#else
PExpr newLoop (cond, attr, iter, coord)
   PExpr cond; PExpr attr; PExpr iter; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = LoopKind;
  res->u.loop.cond = cond;
  res->u.loop.attr = attr;
  res->u.loop.iter = iter;
  return res;
}/* newLoop */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newName (int name, CoordPtr coord)
#else
PExpr newName (name, coord) int name; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = NameKind;
  res->u.name = name;
  return res;
}/* newName */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newIntValue (int val, CoordPtr coord)
#else
PExpr newIntValue (val, coord) int val; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = IntValueKind;
  res->u.intValue = val;
  return res;
}/* newIntValue */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newStrValue (int val, CoordPtr coord)
#else
PExpr newStrValue (val, coord) int val; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = StrValueKind;
  res->u.strValue = val;
  return res;
}/* newStrValue */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newChrValue (int val, CoordPtr coord)
#else
PExpr newChrValue (val, coord) int val; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = ChrValueKind;
  res->u.chrValue = val;
  return res;
}/* newChrValue */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newFltValue (int val, CoordPtr coord)
#else
PExpr newFltValue (val, coord) int val; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = FltValueKind;
  res->u.fltValue = val;
  return res;
}/* newFltValue */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newAttrAccRule 
  (ProdSymbol prodSymb, DefTableKey attrKey, int isChain, CoordPtr coord)
#else
PExpr newAttrAccRule (prodSymb, attrKey, isChain, coord)
  ProdSymbol prodSymb; DefTableKey attrKey; int isChain; CoordPtr coord;
#endif
{ PExpr res;
  if (prodSymb == NoProdSymbol) return wrongExpr;
  res = allocExpr (coord);
  res->exprKind = AttrAccRuleKind;
  res->u.attrAccRule.prodSymb = prodSymb;
  res->u.attrAccRule.attrKey = attrKey;
  res->u.attrAccRule.isChain = isChain;
  return res;
}/* newAttrAccRule */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newRuleAttrAcc (DefTableKey attrKey, CoordPtr coord)
#else
PExpr newRuleAttrAcc (attrKey, coord) DefTableKey attrKey; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = RuleAttrAccKind;
  res->u.ruleAttrAcc.attrKey = attrKey;
  return res;
}/* newRuleAttrAcc */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newAttrAccSymb
  (DefTableKey symbKey, DefTableKey attrKey, int isChain, CoordPtr coord)
#else
PExpr newAttrAccSymb (symbKey, attrKey, isChain, coord)
  DefTableKey symbKey; DefTableKey attrKey; int isChain; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = AttrAccSymbKind;
  res->u.attrAccSymb.symbKey = symbKey;
  res->u.attrAccSymb.attrKey = attrKey;
  res->u.attrAccSymb.isChain = isChain;
  return res;
}/* newAttrAccSymb */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newIncluding (DefTableKey inclKey, CoordPtr coord)
#else
PExpr newIncluding (inclKey, coord) DefTableKey inclKey; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = IncludingKind;
  res->u.remote.remKey = inclKey;
  res->u.remote.subtree = 0; /* irrelevant */
  return res;
}/* newIncluding */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newConstituent (DefTableKey constKey, int subtree, CoordPtr coord)
#else
PExpr newConstituent (constKey, subtree, coord) 
DefTableKey constKey; int subtree; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = ConstituentKind;
  res->u.remote.remKey = constKey;
  res->u.remote.subtree = subtree;
  return res;
}/* newConstituent */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newConstituents (DefTableKey constKey, int subtree, CoordPtr coord)
#else
PExpr newConstituents (constKey, subtree, coord) 
DefTableKey constKey; int subtree; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = ConstituentsKind;
  res->u.remote.remKey = constKey;
  res->u.remote.subtree = subtree;
  return res;
}/* newConstituents */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newSymbTermAcc (int index, CoordPtr coord)
#else
PExpr newSymbTermAcc (index, coord) int index; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = SymbTermAccKind;
  res->u.symbTerm = index;
  return res;
}/* newSymbTermAcc */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newRuleTermAcc (int symbNo, DefTableKey termKey, CoordPtr coord)
#else
PExpr newRuleTermAcc (symbNo, termKey, coord) 
  int symbNo; DefTableKey termKey; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = RuleTermAccKind;
  res->u.ruleTerm.symbNo = symbNo;
  res->u.ruleTerm.symbKey = termKey;
  return res;
}/* newRuleTermAcc */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newRHS (int attrIdn, CoordPtr coord)
#else
PExpr newRHS (attrIdn, coord) int attrIdn; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = RHSKind;
  res->u.attrIdn = attrIdn;
  return res;
}/* newRHS */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newHeadAcc (DefTableKey chnKey, CoordPtr coord)
#else
PExpr newHeadAcc (chnKey, coord) DefTableKey chnKey; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
#ifdef TEST
  printf ("newHEADAcc line %d\n", LineOf (*coord));
#endif
  res->exprKind = HeadAccKind;
  res->u.chnKey = chnKey;
  return res;
}/* newHeadAcc */

#if defined(__cplusplus) || defined(__STDC__)
PExpr newTailAcc (DefTableKey chnKey, CoordPtr coord)
#else
PExpr newTailAcc (chnKey, coord) DefTableKey chnKey; CoordPtr coord;
#endif
{ PExpr res = allocExpr (coord);
  res->exprKind = TailAccKind;
  res->u.chnKey = chnKey;
  return res;
}/* newTailAcc */

#if defined(__cplusplus) || defined(__STDC__)
PExpr copyExpr (PExpr ex)
#else
PExpr copyExpr (ex) PExpr ex;
#endif
/* the result is a deep copy of ex */
{ /* first a flat copy: */
  PExpr res = allocExpr (ex->coord);
  res->exprKind = ex->exprKind;
  res->u = ex->u;

  /* extend the flat copy recursively to a deep copy: */
  switch (ex->exprKind)
  {
    case CallKind:
      res->u.call.params = CopyPExprList (ex->u.call.params, copyExpr);
      break;
    case ExprListKind:
      res->u.subList = CopyPExprList (ex->u.subList, copyExpr);
      break;
    case LoopKind:
      res->u.loop.cond = copyExpr (ex->u.loop.cond);
      res->u.loop.attr = copyExpr (ex->u.loop.attr);
      res->u.loop.iter = copyExpr (ex->u.loop.iter);
      break;
    case DependKind:
      res->u.depend.ex = copyExpr (ex->u.depend.ex);
      res->u.depend.deps = CopyPExprList (ex->u.depend.deps, copyExpr);
      break;
    case AssignKind:
      res->u.assign.left = copyExpr (ex->u.assign.left);
      res->u.assign.right = copyExpr (ex->u.assign.right);
      break;
    default:;
      /* no sub-expression to be copied */
  }
  return res;
}/* copyExpr */
~}

~O~<Compute.specs~>~{
$/Tech/MakeName.gnrc +instance=Identifier :inst
~}

~O~<InheritRepr.h~>==~{
#include "args.h"

#include "ComputationRepr.h"
extern DefTableKey CreateBUAssignAttr 
  FEARGS ((DefTableKey context, DefTableKey attr, CoordPtr coord));

extern PExpr TurnPlainBUIntoAssign
  FEARGS ((DefTableKey context, DefTableKey attr, PExpr plain, CoordPtr coord));

extern void InheritRepr ();
~}
~O~<InheritRepr.c~>==~{
#include "InheritRepr.h"
#include "Inherit.h"
#include "CompRepr.h"
#include "GrammarRules.h"
#include "Prod.h"
#include "Grammar.h"
#include "Attribute.h"
#include "pdl_gen.h"
#include "csm.h"
#include "Strings.h"
#include "MakeName.h"

#ifdef TEST
#define TEST
#include <stdio.h>
#endif

#if defined(__cplusplus) || defined(__STDC__)
DefTableKey CreateBUAssignAttr
  (DefTableKey context, DefTableKey attr, CoordPtr coord)
#else
DefTableKey CreateBUAssignAttr (context, coord) 
  DefTableKey context, attr; CoordPtr coord;
#endif
/* An attribute is created for the lhs of a plain BU computation
   the lhs attr is a new rule-attr if context is a rule,
   it is the computation attr if context is a symbol;
   in either case IsPlain is NOT set, to keep the attr in the output
*/
{ 
  Environment attrScope = GetAttrScope (context, NoEnv);
  if (GetIsRule (context, 0))
  { 
    int sym = GenerateName ("_BUPlain");
    attr = KeyOf (BindIdn (attrScope, sym));
    ResetNameSym (attr, sym);
    ResetRuleOfAttr (attr, context);
    ResetCoord (attr, coord);
  }
  ResetIsPlain (attr, 0);
  ResetAttrClass (attr, SYNTClass);
  ResetAttrType (attr, VOIDkey);
  ResetIsDefined (attr, 1);
#ifdef TEST
  printf ("CreateBUAssignAttr attr %s of %s\n",
          StringTable (GetNameSym (attr, 0)), 
          StringTable (GetNameSym (context, 0)));
#endif
  return attr;
}/* CreateBUAssignAttr */

#if defined(__cplusplus) || defined(__STDC__)
PExpr TurnPlainBUIntoAssign
  (DefTableKey context, DefTableKey attr, PExpr plain, CoordPtr coord)
#else
PExpr TurnPlainBUIntoAssign (context, attr, plain, coord) 
  DefTableKey context; DefTableKey attr; PExpr plain; CoordPtr coord;
#endif
/* The plain computation is turned into an assignment;
   the lhs attr is a rule-attr if context is a rule,
   it is a symbol-attr if context is a symbol;
*/
{
  PExpr lhs = 
    GetIsRule (context, 0) ?
      newRuleAttrAcc (attr, coord) :
      newAttrAccSymb (context, attr, 0, coord);
  return newAssign (lhs, plain, coord);
}/* TurnPlainBUIntoAssign */

#if defined(__cplusplus) || defined(__STDC__)
void instantiateExpr (PExpr ex, RuleProd rule, ProdSymbol symocc)
#else
void instantiateExpr (ex, rule, symocc) 
  PExpr ex; RuleProd rule; ProdSymbol symocc;
#endif
/* the result is a deep copy of ex */
{ PExprList exl;
#ifdef TEST
  printf ("instantiateExpr kind %d\n", ex->exprKind);
#endif
  switch (ex->exprKind)
  {
    case AttrAccSymbKind:
      { int isChain = ex->u.attrAccSymb.isChain;
        DefTableKey attrKey;
        if (isChain)
           attrKey = ex->u.attrAccSymb.attrKey;
        else
           attrKey = 
             KeyInEnv 
               (GetAttrScope (symocc->u.s.symbolkey, NoEnv),
                GetNameSym (ex->u.attrAccSymb.attrKey, 0));

       ex->exprKind = AttrAccRuleKind;
       ex->u.attrAccRule.prodSymb = symocc;
       ex->u.attrAccRule.attrKey = attrKey;
       ex->u.attrAccRule.isChain = isChain;
       return;
      }
    case SymbTermAccKind:
      { int symbNo = 0, index;
        ProdSymbol s;
        ProdSymbolList rhs = TailProdSymbolList (rule->prod);

        if (symocc->u.s.symbolpos > 0)
        { ex->exprKind = wrongExprKind;
          return;
        }

        index = ex->u.symbTerm; 
        if (index == 0) index = 1;
        if (rule->islistof) rhs = NULLProdSymbolList;

        while (rhs != NULLProdSymbolList)
        { s = HeadProdSymbolList (rhs);
          symbNo++;
          if (s->kind == IsProdSymbol && GetIsTerm (s->u.s.symbolkey, 0))
          { 
#ifdef TEST
  printf ("TERM[%d] symbolpos: %d\n", index, s->u.s.symbolpos);
#endif
            if (s->u.s.symbolpos == index) break; 
          }
          rhs = TailProdSymbolList (rhs);
        }
        if (rhs == NULLProdSymbolList)
        { message (ERROR, CatStrInd
                     ("Too few terminals in rule ",
                      GetNameSym (RuleKeyOfRuleProd (rule), 0)),
                   0, ex->coord);
          ex->exprKind = wrongExprKind;
          return;          
        }
        ex->exprKind = RuleTermAccKind;
        ex->u.ruleTerm.symbNo = index;
        ex->u.ruleTerm.symbKey = s->u.s.symbolkey;
        return;
      }
    case CallKind:
      exl = ex->u.call.params;
      while (exl != NULLPExprList)
      { instantiateExpr (HeadPExprList (exl), rule, symocc);
        exl = TailPExprList (exl);
      }
      break;
    case LoopKind:
      instantiateExpr (ex->u.loop.cond, rule, symocc);
      instantiateExpr (ex->u.loop.attr, rule, symocc);
      instantiateExpr (ex->u.loop.iter, rule, symocc);
      break;
    case DependKind:
      instantiateExpr (ex->u.depend.ex, rule, symocc);
      exl = ex->u.depend.deps;
      while (exl != NULLPExprList)
      { instantiateExpr (HeadPExprList (exl), rule, symocc);
        exl = TailPExprList (exl);
      }
      break;
    case AssignKind:
      instantiateExpr (ex->u.assign.left, rule, symocc);
      instantiateExpr (ex->u.assign.right, rule, symocc);
      break;
    case ExprListKind:
      exl = ex->u.subList;
      while (exl != NULLPExprList)
      { instantiateExpr (HeadPExprList (exl), rule, symocc);
        exl = TailPExprList (exl);
      }
      break;
    default:;
      /* no sub-expression to be instantiated */
  }
  return;
}/* instantiateExpr */

void instantiateComputation
#if defined(__cplusplus) || defined(__STDC__)
      (Binding rulecomp, Binding orig, RuleProd rule, ProdSymbol symb)
#else
      (rulecomp, orig, rule, symb)
      Binding rulecomp, orig; RuleProd rule; ProdSymbol symb;
#endif
/* on entry:
   rulecomp is a computation binding in the context of the rule rule or 
     of the symbol occurrence symb of rule
   orig is a computation binding which is to be inherited
     if rulecomp has no code associated by CompRepr
   on exit:
   if rulecomp has code associated by CompRepr it is left unchanged,
     otherwise the inherited computation is instantiated for that
     rule context
*/
{ 
  PExpr sourceEx = GetCompRepr (KeyOf(orig), NULLPExpr);
  PExpr targetEx = GetCompRepr (KeyOf(rulecomp), NULLPExpr);
  DefTableKey sourceIsChainStart = GetIsChainStart(KeyOf(orig), NoKey);

  if (targetEx ==  NULLPExpr)
  {
#ifdef TEST
  printf ("inherited repr from line %d\n", LineOf(*(sourceEx->coord)));
#endif
    /* the source expression is copied, then modified by recursive
       calls of instantiateExpr: 
    */
    targetEx = copyExpr (sourceEx);
    instantiateExpr (targetEx, rule, symb);

    ResetCompRepr (KeyOf(rulecomp), targetEx);
    ResetIsBottomUp (KeyOf(rulecomp), 
         GetIsBottomUp (KeyOf(orig), 0));

    if ((sourceIsChainStart != NoKey) &&
        (GetEmptyHEADAttr (KeyOf(rulecomp), NoKey) == NoKey))
         ResetIsChainStart (KeyOf(rulecomp), sourceIsChainStart);
    else ResetIsChainStart (KeyOf(rulecomp), NoKey);
  }
}/* instantiateComputation */

void InheritRepr ()
/* on entry:
     All inherited computations are bound in the computation scopes 
     of the symbol occurrences.
     Each such key of an inherited computation is related to
     the original symbol computation by the property InheritedFrom.
     All original computations have representations.
   on exit:
     All inherited computations have a representation which is
     instantiated from the original symbol computation
*/
{ RuleProdList rules;
  Binding rulecomp;
#ifdef TEST
  printf ("InheritRepr started\n"); 
#endif

  /* step through all nonterminal occurrences of productions: */
  rules = GrammarRules;
  while (rules != NULLRuleProdList)
  { RuleProd rule = HeadRuleProdList (rules);
    ProdSymbolList prod = rule->prod;
    DefTableKey ruleKey = RuleKeyOfRuleProd (rule);
    ProdSymbol symb = HeadProdSymbolList (prod);
    int inRootRule = 0;
#ifdef TEST
    int i = 0;
   printf ("RULE %s:\n", 
      StringTable (GetNameSym (ruleKey, 0)));
#endif
    rulecomp = DefinitionsOf(GetLowerScope(ruleKey, NoEnv));
    while (rulecomp != NoBinding)
    { Binding orig = GetInheritedFrom (KeyOf(rulecomp), NoBinding);
      if (orig != NoBinding)
        instantiateComputation (rulecomp, orig, rule, symb);
      rulecomp = NextDefinition(rulecomp);
    }
 #ifdef TEST
  printf ("computations at symb occs:\n"); 
#endif 
    while (prod != NULLProdSymbolList)
    { 
#ifdef TEST
  printf ("symb occ %d:\n", i++); 
#endif 
      symb = HeadProdSymbolList (prod);
      if (symb->kind != IsProdLiteral && 
          !GetIsTerm (symb->u.s.symbolkey, 0))
      { Environment syenv = symb->u.s.scope;
#ifdef TEST
  printf ("symbol %s:\n", 
     StringTable (GetNameSym (symb->u.s.symbolkey, 0)));
#endif
        rulecomp = DefinitionsOf(syenv);
        while (rulecomp != NoBinding)
        { Binding orig = GetInheritedFrom (KeyOf(rulecomp), NoBinding);
          if (orig != NoBinding)
            instantiateComputation (rulecomp, orig, rule, symb);
          rulecomp = NextDefinition(rulecomp);
        }
      }
      if (rule->islistof) break;
      prod = TailProdSymbolList (prod);
    }
    rules = TailRuleProdList (rules);
  }
#ifdef TEST
  printf ("InheritRepr completed\n"); 
#endif
}/* InheritRepr */
~}

~O~<CheckRuleComps.head~>==~{
#include "CheckRuleComps.h"
~}
~O~<CheckRuleComps.h~>==~{
extern void CheckRuleComps ();
~}
~O~<CheckRuleComps.c~>==~{
#include "CheckRuleComps.h"
#include "CompRepr.h"
#include "GrammarRules.h"
#include "Grammar.h"
#include "pdl_gen.h"
#include "csm.h"
#include "Strings.h"
#include "Predefined.h"
#include "PreDefId.h"
#include "Remote.h"
#include "Inherit.h"
#include "SymbolOcc.h"

extern Environment RootEnv; /* exported by AlgScope.h */

#ifdef TEST
#define TEST
#include <stdio.h>
#endif

static RuleProd currRule;
static ProdSymbol currSymbOcc;
static DefTableKey currCompKey;
static PExprList loopAttributes;

#if defined(__cplusplus) || defined(__STDC__)
PExprList ExpandExprList (PExprList left, PExprList right);
#else
PExprList ExpandExprList ();
#endif

#if defined(__cplusplus) || defined(__STDC__)
PExprList ConsRHSAttrList
  (ProdSymbolList rhs, int attrIdn, CoordPtr coord)
#else
PExprList ConsRHSAttrList (rhs, attrIdn, coord) 
  ProdSymbolList rhs; int attrIdn; CoordPtr coord;
#endif
/* recursive construction of a list of attribute accesses
   X.attrIdn, one for each nonterminal of rhs
*/
{ PExprList res;
  ProdSymbol sy;
  if (rhs == NULLProdSymbolList) 
     return NULLPExprList;
  res = ConsRHSAttrList (TailProdSymbolList (rhs), attrIdn, coord);
  sy = HeadProdSymbolList (rhs);
  if (sy->kind != IsProdLiteral && !GetIsTerm (sy->u.s.symbolkey, 0))
  { Environment attrenv = GetAttrScope (sy->u.s.symbolkey, NoEnv);
    Binding attrBind = BindingInScope (attrenv, attrIdn);
    if (attrBind == NoBinding)
    { message (ERROR, CatStrInd 
                 ("RHS attribute is missing for ", 
                  GetNameSym (sy->u.s.symbolkey, 0)),
               0, coord);
      return res;
    }
    return
      ConsPExprList 
        (newAttrAccRule (sy, KeyOf(attrBind), 0, coord), res);
   }
  return res;
}/* ConsRHSAttrList */

void ResetOpenInclProp () {
#ifdef TEST
  printf ("ResetOpenInclProp\n");
#endif
  DefTableKeyList skl = TreeSymbols;
  while (skl != NULLDefTableKeyList) {
    DefTableKey k = HeadDefTableKeyList (skl);
    ResetInRemoteSet (k, 0);
    ResetDerivableVisited (k, 0);
    skl = TailDefTableKeyList (skl);
  }
}/* ResetOpenInclProp */

int DerivableWithoutRemSet (DefTableKey symKey) {
/* on entry:
     The list of symbol keys DerivableFrom is set for each tree symbol.
     The symbol keys of the remote set are indicated by InRemoteSet.
     Symbols which need not be checked again are indicated by DerivableVisited.
   on exit:
     1 is returned, if symKey can be derived from the GrammarRoot without
     deriving a symbol of the remote set.
     Otherwise, 0 is returned.
*/
   /* The candidates to be checked: */
   DefTableKeyList drvl = GetDerivableFrom (symKey, NULLDefTableKeyList);

#ifdef TEST
  printf ("DerivableWithoutRemSet for symbol %s:\n", 
           StringTable (GetNameSym (symKey, 0)));
#endif
   if (symKey == NoKey) return 0;
   if (symKey == GrammarRoot) return 1;
   if (GetInRemoteSet (symKey, 0)) return 0;
   if (GetDerivableVisited (symKey, 0)) return 0;
   ResetDerivableVisited (symKey, 1);

   while (drvl != NULLDefTableKeyList) {
     DefTableKey lhsKey = HeadDefTableKeyList (drvl);
     if (DerivableWithoutRemSet (lhsKey))
        return 1;
     drvl = TailDefTableKeyList (drvl);
   }
   return 0;
}/* DerivableWithoutRemSet */

void CheckOpenIncl (DefTableKey inclKey, RuleProd treeContext, CoordPtr inclCoord) {
  /* The INCLUDING-construct inclKey is instantiated in treeContext 
        at position inclCoord.
     It is checked whether a tree symbol of the remote set is reached from this context.
  */

  DefTableKey lhsKey = (HeadProdSymbolList (treeContext->prod))->u.s.symbolkey;
  SymbAttrList remAttrList = GetRemoteSet (inclKey, NULLSymbAttrList);
  SymbAttrList ral = remAttrList;

#ifdef TEST
  printf ("CheckOpenIncl in line %d begin\n", LineOf(*inclCoord));
#endif
  /* clear the properties InRemoteSet and DerivableVisited for all tree symbols: */
  ResetOpenInclProp ();
  
  /* Set InRemoteSet for the tree symbols of the current including: */
  while (ral != NULLSymbAttrList) {
    SymbAttr sa = HeadSymbAttrList (ral);
    DefTableKey sym = KeyOf (sa->symbolbind);
    if (sym == GrammarRoot) /* including cannot fail */
       return;
    ResetInRemoteSet (sym, 1);
#ifdef TEST
  printf ("  Set InRemoteSet %s\n", StringTable (GetNameSym (sym, 0)));
#endif
    ral = TailSymbAttrList (ral);
  }

  if (DerivableWithoutRemSet (lhsKey)) {
    message (ERROR, CatStrInd 
                      ("No INCLUDING symbol is found in RULE context ", 
                       GetNameSym (RuleKeyOfRuleProd (treeContext), 0)), 0, inclCoord);
  }
#ifdef TEST
  printf ("CheckOpenIncl in line %d end\n", LineOf(*inclCoord));
#endif
}/* CheckOpenIncl */


#if defined(__cplusplus) || defined(__STDC__)
void ExpandRHSAttr (PExpr ex)
#else
void ExpandRHSAttr (ex) PExpr ex;
#endif
/* if RHS.a is allowed in the enclosing rule context, 
   ex is substituted by an expression list, 
   that will be embedded later
*/
{ ProdSymbolList rhs;
  ProdSymbol sy; 
  PExprList res;
  if (currRule->islistof)
  { message (ERROR, "RHS not allowed in LISTOF rule",
             0, ex->coord);
    ex->exprKind = wrongExprKind;
    return;
  }
  res =
    ConsRHSAttrList 
       (TailProdSymbolList (currRule->prod),
        ex->u.attrIdn,
        ex->coord);
  ex->exprKind = ExprListKind;
  ex->u.subList = res;
}/* ExpandRHSAttr */

#if defined(__cplusplus) || defined(__STDC__)
int getPrefix (PExpr ex, PExprList params)
#else
int getPrefix (ex, params) PExpr ex; PExprList params;
#endif
{ PExpr first; 
  if (params == NULLPExprList)
  { message (ERROR, "Arguments of function call missing", 
             0, ex->coord);
    ex->exprKind = wrongExprKind;
    return 0;
  }
  first = HeadPExprList (params);
  if (first->exprKind != StrValueKind)
  { message (ERROR, 
             "First argument of function call must be a string", 
             0, ex->coord);
    ex->exprKind = wrongExprKind;
    return 0;
  }
  return first->u.strValue;
}/* getPrefix */

#if defined(__cplusplus) || defined(__STDC__)
PExprList ConsTermCallList 
   (int prefix, ProdSymbolList rhs, int symbNo, 
    PExprList params, CoordPtr coord)
#else
PExprList ConsTermCallList (prefix, rhs, symbNo, params, coord)
   int prefix; ProdSymbolList rhs; int symbNo; 
   PExprList params; CoordPtr coord;
#endif
{ ProdSymbol sy;
  if (rhs == NULLProdSymbolList) return NULLPExprList;
  sy = HeadProdSymbolList (rhs);
  if (sy->kind != IsProdLiteral && GetIsTerm (sy->u.s.symbolkey, 0))
    return
      ConsPExprList
       (newCall 
           (IndCatStrStr
              (StringTable (prefix),
               StringTable (GetNameSym (sy->u.s.symbolkey, 0))),
            ConsPExprList
              (newRuleTermAcc (symbNo, sy->u.s.symbolkey, coord),
	       params),
            coord),
        ConsTermCallList
          (prefix,
           TailProdSymbolList (rhs), 
           symbNo+1,
           params,
           coord));
   else
     return 
        ConsTermCallList
          (prefix, 
	   TailProdSymbolList (rhs),
           symbNo,
           params,
           coord);
}/* ConsTermCallList */

#if defined(__cplusplus) || defined(__STDC__)
void ExpandTermFct (PExpr ex)
#else
void ExpandTermFct (ex) PExpr ex;
#endif
/*         ex is a TermFct call of the form
	   TermFct ("Pre", a1,...,an)
           Let  X ::= ... Ta ... Tb ... 
           be the rule containing that call, 
           where Ta and Tb are the only terminals.
           Then the result is an argument sequence
	   PreTa (Ta, a1,...,an), PreTb (Tb, a1,...,an)
           where a1,...,an are recursively substituted.
*/
{ PExprList params = 
     ExpandExprList (ex->u.call.params, NULLPExprList);
  int prefix = getPrefix (ex, params);
  if (prefix == 0) return;

  ex->u.subList =
    ConsTermCallList 
      (prefix, 
       TailProdSymbolList (currRule->prod), 1,
       TailPExprList (params),
       ex->coord);
  ex->exprKind = ExprListKind;
}/* ExpandTermFct */

#if defined(__cplusplus) || defined(__STDC__)
PExprList ExpandExprList (PExprList left, PExprList right)
#else
PExprList ExpandExprList (left, right) PExprList left, right;
#endif
/* on entry
     left and right are expression lists in rule context
          evaluated for currSymOcc
     right is expanded and is to be appended to the expansion
     left
   on exit
     the expanded list is returned;
     any occurrence of RHS and TermFct in exl are expanded;
     the result list flattened
     other transformations or checks are not yet performed
*/
{ PExpr thisEx;
  if (left == NULLPExprList)
     return right;

  thisEx = HeadPExprList (left);
  if (thisEx->exprKind == RHSKind)
       ExpandRHSAttr (thisEx);
  else if ((thisEx->exprKind == CallKind) &&
           (thisEx->u.call.idn == TermFctsym))
       ExpandTermFct (thisEx);

  if (thisEx->exprKind == ExprListKind)
       return 
         ExpandExprList 
           (thisEx->u.subList,
            ExpandExprList (TailPExprList (left), right));

  else {
    left->tail =
        ExpandExprList (TailPExprList (left), right);
    return left;
  }         
}/* ExpandExprList */

#if defined(__cplusplus) || defined(__STDC__)
void CheckTrafoExpr (PExpr ex, int isVoid);
#else
void CheckTrafoExpr ();
#endif

#if defined(__cplusplus) || defined(__STDC__)
void CheckTrafoExprList (PExprList exl, int isVoid)
#else
void CheckTrafoExprList (exl, isVoid) 
   PExprList exl; int isVoid;
#endif
/* on entry
     exl is an expression list in rule context, evaluated for 
     currSymOcc in VOID context if isVoid indicates so.
     RHS and TermFct are already expanded in exl
   on exit
     the elements of exl are checked and transformed
*/
{ while (exl != NULLPExprList)
  { CheckTrafoExpr (HeadPExprList (exl), isVoid);
    exl = TailPExprList (exl);
  }
}/* CheckTrafoExprList */


#if defined(__cplusplus) || defined(__STDC__)
DefTableKey AttrAccType (PExpr ex)
#else
DefTableKey AttrAccType (ex) PExpr ex;
#endif
{ DefTableKey tp;
  if (ex == wrongExpr) return intkey;
  switch (ex->exprKind)
  { case AttrAccRuleKind:
      tp = GetAttrType (ex->u.attrAccRule.attrKey, VOIDkey);
      break;
    case RuleAttrAccKind:
      tp = GetAttrType (ex->u.ruleAttrAcc.attrKey, VOIDkey);
      break;
    case wrongExprKind:
      return intkey;
    default:
      tp = VOIDkey;
  }
  return tp;
}/* AttrAccType */

#if defined(__cplusplus) || defined(__STDC__)
void MsgEmptyRemoteSet (DefTableKey remkey, CoordPtr coord)
#else
void MsgEmptyRemoteSet (remkey, coord) 
  DefTableKey remkey; CoordPtr coord;
#endif
{ 
if (GetRemoteSet (remkey, NULLSymbAttrList) == NULLSymbAttrList) 
  {
    DefTableKey inhcontext = 
      GetContext (KeyOf (GetInheritedFrom (currCompKey, NoBinding)), NoKey);
    DefTableKey context = GetContext (currCompKey, NoKey);

    if (GetRemoteEpxrIsErr (remkey, 0)) return;
      /* the remote construct is reported to be erroneous */

    if (inhcontext != NoKey && !GetIsTreeSym (inhcontext, 0)) {
      message (ERROR, 
               "This empty set of remote attributes is inherited by some RULE",
               0, coord);
      message (ERROR, "Symbol inherits a computation with an empty remote set",
               0, currSymbOcc->u.s.coord);
    } else
      message (ERROR, "Set of remote attributes is empty", 0, coord);
  }  
}/* MsgEmptyRemoteSet */

#if defined(__cplusplus) || defined(__STDC__)
void CheckAllAttrsValue (DefTableKey remKey, int isIncl, CoordPtr coord)
#else
void CheckAllAttrsValue (remKey, isIncl, coord) 
  DefTableKey remkey; int isIncl; CoordPtr coord;
#endif
/* check whether all remote attrs are non-VOID */
{
  SymbAttrList sal = 
      GetRemoteSet (remKey, NULLSymbAttrList);

  if (GetRemoteEpxrIsErr (remKey, 0)) return;
    /* the remote construct is reported to be erroneous */

  while (sal != NULLSymbAttrList) {
    Environment syAttrs = 
      GetAttrScope (KeyOf(SymbolBindOf(HeadSymbAttrList (sal))),
                    NoEnv);
    Binding atb = 
      BindingInEnv (syAttrs, AttrOf(HeadSymbAttrList (sal)));
    if (atb != NoBinding && 
        GetAttrType (KeyOf(atb), VOIDkey) == VOIDkey) {
      if (isIncl)
        message (ERROR, "VOID INCLUDING in value context",
                 0, coord);
      else
        message (ERROR, "VOID CONSTITUENT(S) in value context",
                 0, coord);
      break;
    }
    sal = TailSymbAttrList (sal);
  }
}/* CheckAllAttrsValue */

#if defined(__cplusplus) || defined(__STDC__)
void CheckTrafoExpr (PExpr ex, int isVoid)
#else
void CheckTrafoExpr (ex, isVoid) 
   PExpr ex; int isVoid;
#endif
/* on entry
     ex is an expression in rule context, evaluated for currSymOcc
     in VOID context if isVoid indicates so.
   on exit
     ex is recursively checked and transformed
*/
{
  if (ex == wrongExpr) return;
#ifdef TEST
  printf ("CheckTrafo ExprKind %d \n", ex->exprKind);
#endif
  switch (ex->exprKind)
  {
    case CallKind:
#ifdef TEST
  printf ("CheckTrafo call %s %d predef %d\n", 
          StringTable(ex->u.call.idn), ex->u.call.idn,
          IsPredefSym(ex->u.call.idn));
#endif
      ex->u.call.params = 
        ExpandExprList (ex->u.call.params, NULLPExprList);

      if (IsPredefSym (ex->u.call.idn))
      { PExprList params = ex->u.call.params;
        /*                    -----*/
        if (ex->u.call.idn == IFsym)
        { if (params == NULLPExprList)
          { message (ERROR, "Arguments of IF missing", 
                     0, ex->coord);
            break;
          }
          CheckTrafoExpr (HeadPExprList (params), 0);
          params = TailPExprList (params);
          if (params == NULLPExprList)
          { message (ERROR, "Arguments of IF missing", 
                     0, ex->coord);
            break;
          }
          CheckTrafoExpr (HeadPExprList (params), isVoid);
          params = TailPExprList (params);
          if (params == NULLPExprList)
          { if (!isVoid)
              message (ERROR, "IF needs else part in value context", 
                       0, ex->coord);
            break;
          }
          CheckTrafoExpr (HeadPExprList (params), isVoid);
	  params = TailPExprList (params);
	  if (params != NULLPExprList)
		message (ERROR, "IF has more than 3 arguments",
                         0, ex->coord);
        } else
        /*                    --------*/
        if (ex->u.call.idn == ORDERsym)
        { 
          if (params == NULLPExprList)
          { message (ERROR, "Arguments of ORDER missing", 
                     0, ex->coord);
            break;
          }
          while (TailPExprList (params) != NULLPExprList)
          {
            CheckTrafoExpr (HeadPExprList (params), 1);
            params = TailPExprList (params);
          }
          CheckTrafoExpr (HeadPExprList (params), isVoid);
        } else
        /*                    ----------*/
        if (ex->u.call.idn == RuleFctsym)
        { int prefix = getPrefix (ex, params);
          int ruleName = 
            GetNameSym (RuleKeyOfRuleProd (currRule), 0);
#ifdef TEST
  printf ("RuleFct begin\n"); 
#endif
          CheckTrafoExprList (params, 0);
          if (prefix == 0)
             break;
          /* create new call identifier: */
          ex->u.call.idn = 
            IndCatStrStr 
              (StringTable (prefix),
               StringTable (ruleName));
          ex->u.call.params = TailPExprList(params);
#ifdef TEST
  printf ("RuleFct end\n"); 
#endif
        } else
        /*                    ---------*/
        if (ex->u.call.idn == RhsFctsym)
        { int prefix = getPrefix (ex, params);
          int nonterms = 0, terms = 0;
          char buffer [64];
          ProdSymbolList rhs = 
             TailProdSymbolList (currRule->prod);
#ifdef TEST
  printf ("RhsFct begin\n"); 
#endif
          CheckTrafoExprList (params, 0);
          if (prefix == 0)
             break;
          while (rhs != NULLProdSymbolList)
          { ProdSymbol sy = HeadProdSymbolList (rhs);
            if (sy->kind != IsProdLiteral) {
              if (GetIsTerm (sy->u.s.symbolkey, 0))
                   terms++;
              else nonterms++;
            }
            rhs = TailProdSymbolList (rhs);
          }
          /* create new call identifier: */
          sprintf (buffer, "Rhs_%d_%d", nonterms, terms);
          ex->u.call.idn = 
            IndCatStrStr 
              (StringTable (prefix),
               buffer);
          ex->u.call.params = TailPExprList(params);
#ifdef TEST
  printf ("RhsFct end\n"); 
#endif
        } else
        /*                    ---------*/
        if (ex->u.call.idn == TermFctsym)
        { ExpandTermFct (ex);
          CheckTrafoExpr (ex, isVoid);
        } else

        { message (ERROR, CatStrInd
                   ("Unknown predefined function: ",
                    ex->u.call.idn),
                   0, ex->coord);
          ex->exprKind = wrongExprKind;
          break;
        }
      } else
         CheckTrafoExprList (ex->u.call.params, 0);
      break;
    case ExprListKind:
    /* only a singleton list can be accepted as an expression: */
      if (LengthPExprList (ex->u.subList) == 1)
      { int kd = (HeadPExprList (ex->u.subList))->exprKind;
        ex->u = (HeadPExprList (ex->u.subList))->u;
	ex->exprKind = kd;
	CheckTrafoExpr (ex, isVoid);
      } else 
      { 
        DefTableKey inhcontext = 
          GetContext 
            (KeyOf (GetInheritedFrom (currCompKey, NoBinding)), NoKey);

        if (inhcontext != NoKey && !GetIsTreeSym (inhcontext, 0)) {
           message 
             (ERROR, 
              "Resulting sequence of expressions is illegal in some context",
              0, ex->coord);
	   message 
             (ERROR, 
              "Symbol inherits an illegal application of RHS or TermFct",
              0, currSymbOcc->u.s.coord);
        } else
           message 
             (ERROR, 
              "Resulting sequence of expressions is illegal",
              0, ex->coord);

        ex->exprKind = wrongExprKind;
      }
      break;
    case DependKind:
      CheckTrafoExpr (ex->u.depend.ex, isVoid);
      ex->u.depend.deps = 
        ExpandExprList (ex->u.depend.deps, NULLPExprList);
      CheckTrafoExprList (ex->u.depend.deps, 1);
      break;
    case NameKind:
      if (IsPredefSym (ex->u.name))
      { if (ex->u.name == RULENAMEsym)
        { 
          ex->exprKind = StrValueKind;
          ex->u.strValue =
            GetNameSym (RuleKeyOfRuleProd (currRule), 0);
        }
        /* unchanged predefined names:
           LINEsym COLsym COORDREFsym
        */
      }
      break;
    case IntValueKind:
    case StrValueKind:
    case ChrValueKind:
    case FltValueKind:
      /* nothing to be done */
      break;
    case AttrAccRuleKind:
    case RuleAttrAccKind:
      { DefTableKey ak = 
           ex->exprKind == AttrAccRuleKind ?
             ex->u.attrAccRule.attrKey : ex->u.ruleAttrAcc.attrKey;
        int idn = GetNameSym (ak, 0);
        if (idn == GENTREEsym)
             message (ERROR, "GENTREE attribute may only be defined",
                      0, ex->coord);
        if (!isVoid && (AttrAccType (ex) == VOIDkey))
        {
          if (GetAttrTypeDefault (ak, 0))
             message (ERROR, CatStrInd
                      ("attribute with default type VOID in value context: ",
                       idn),
                      0, ex->coord);
          else
             message (ERROR, CatStrInd
                      ("VOID attribute in value context: ", idn),
                      0, ex->coord);
        }
      }
      break;
    case ConstituentsKind:
      if (!isVoid && GetType (ex->u.remote.remKey, NoKey) == NoKey)
        message (ERROR, "WITH clause is missing in value context",
                 0, ex->coord);

      if (isVoid && GetType (ex->u.remote.remKey, NoKey) != NoKey)
        message (WARNING, "WITH clause is not needed in VOID context",
                 0, ex->coord);
      if (!GetIsRuleComputation (currCompKey, 0) &&
          currSymbOcc->u.s.symbolpos > 0) {
        /* transformation in symbol computations: */
	/* CONSTITUENTS in upper context restricted to subtree */
	ex->u.remote.subtree = currSymbOcc->u.s.symbolpos;
      }

      if (GetRemoteSet (ex->u.remote.remKey, NULLSymbAttrList) == 
          NULLSymbAttrList) {
         if (isVoid) {
            /* the empty CONSTITUENTS is replaced by a dummy value: */
           ex->exprKind = IntValueKind;
           ex->u.intValue = 0;
         } else {
             /* An anomaly is encountred. But no message is issued
                to be consistent with previous Liga versions.
             */
             if (GetType (ex->u.remote.remKey, NoKey) == NoKey){
                /* WITH construct is missing */
                 ex->exprKind = IntValueKind;
                 ex->u.intValue = 0;
             } else {
                /* The CONSTITUENTS is replaced by a call of the
                   constant function given in the WITH construct: 
                */
                 ex->exprKind = CallKind;
                 ex->u.call.idn =
                    GetFunct0 (ex->u.remote.remKey, NoStrIndex);
                 ex->u.call.params = NULLPExprList;
             }
         }
         break;
      }

      /* shield clauses are not transformed */

      if (isVoid) ResetInVoidContext (ex->u.remote.remKey, 1);
         else     ResetInValueContext (ex->u.remote.remKey, 1);

      if (!isVoid) 
        CheckAllAttrsValue 
          (ex->u.remote.remKey, 0 /* not IncludingKind */, ex->coord);
      break;

    case ConstituentKind:
      if (!GetIsRuleComputation (currCompKey, 0) &&
          currSymbOcc->u.s.symbolpos > 0) {
        /* transformation in symbol computations: */
	/* CONSTITUENT in upper context restricted to subtree */
	ex->u.remote.subtree = currSymbOcc->u.s.symbolpos;
      }

      if (GetRemoteSet (ex->u.remote.remKey, NULLSymbAttrList) == 
          NULLSymbAttrList) 
        MsgEmptyRemoteSet (ex->u.remote.remKey, ex->coord);

      /* shield clauses are not transformed */

      if (isVoid) ResetInVoidContext (ex->u.remote.remKey, 1);
         else     ResetInValueContext (ex->u.remote.remKey, 1);

      if (!isVoid) 
        CheckAllAttrsValue 
          (ex->u.remote.remKey, 0 /* not IncludingKind */, ex->coord);
      break;

    case IncludingKind: 
      if (GetRemoteSet (ex->u.remote.remKey, NULLSymbAttrList) == 
          NULLSymbAttrList) 
        MsgEmptyRemoteSet (ex->u.remote.remKey, ex->coord);

      if (isVoid) ResetInVoidContext (ex->u.remote.remKey, 1);
         else     ResetInValueContext (ex->u.remote.remKey, 1);

      if (!isVoid) 
        CheckAllAttrsValue 
          (ex->u.remote.remKey, 1/* IncludingKind */, ex->coord);

      /* check Including inherited from upper symbol computation: */
      if (!GetIsRuleComputation (currCompKey, 0) &&
          currSymbOcc->u.s.symbolpos > 0) {
	ProdSymbol lhsOcc = HeadProdSymbolList (currRule->prod);
	DefTableKey lhsKey = lhsOcc->u.s.symbolkey;
        SymbAttrList sal = 
           GetRemoteSet (ex->u.remote.remKey, NULLSymbAttrList);
        while (sal != NULLSymbAttrList) {
        /* search the RemoteSet: */
	  SymbAttr sa = HeadSymbAttrList (sal);
          if (lhsKey == KeyOf(SymbolBindOf(sa))) {
            /* the lhs symbol of the current rule is found,
               substitute this Including by an attribute access: */
	    Environment symEnv = GetAttrScope (lhsKey, NoEnv);
	    ex->exprKind = AttrAccRuleKind;
	    ex->u.attrAccRule.prodSymb = lhsOcc;
	    ex->u.attrAccRule.attrKey = 
                KeyOf(BindingInEnv (symEnv, AttrOf(sa)));
            ex->u.attrAccRule.isChain = 0;
	    return;
          }
          sal = TailSymbAttrList (sal);
        }
      }
      /* check if this INCLUDING may be open in some tree: */
      CheckOpenIncl (ex->u.remote.remKey, currRule, ex->coord);

      break;
    case RHSKind: 
    { ExpandRHSAttr (ex);
      if (ex->exprKind != RHSKind)
         CheckTrafoExpr (ex, isVoid);
      break;
    }
    case TailAccKind:      
      { ProdSymbol symb = FindTAILSymbolOcc (currRule);
        DefTableKey chnKey = ex->u.chnKey;
        /* in rule contexts non empty rhs is checked earlier */
        if (symb == NoProdSymbol)
          { /* TAIL.c in empty rule. Search for a HEAD.c computation: */
#ifdef TEST
  printf ("CheckTrafo TAIL in empty rule line %d\n",
           LineOf(*(ex->coord)));
#endif
	    DefTableKeyList eHEADs = 
              GetEmptyHEADCompsOfRule 
                 (RuleKeyOfRuleProd (currRule), NULLDefTableKeyList);
            while (eHEADs != NULLDefTableKeyList) {
              DefTableKey eHEADcomp = HeadDefTableKeyList (eHEADs);
	      if (chnKey == GetEmptyHEADChain (eHEADcomp, NoKey)) {
		/* There is a HEAD computations; 
                   acess its result from its rule attribute: */
		ex->exprKind = RuleAttrAccKind;
		ex->u.ruleAttrAcc.attrKey = 
                   GetEmptyHEADAttr (eHEADcomp, NoKey);
#ifdef TEST
  printf ("CheckTrafo TAIL line %d: found an attr with HEAD result; chain %s\n",
           LineOf(*(ex->coord)), StringTable (GetNameSym (chnKey, 0)));
#endif
                return;
              }
              eHEADs = TailDefTableKeyList (eHEADs);
            }
	    /* There is no HEAD computation in this context;
               substitute chainacc of lhs symbol: */
            ex->exprKind = AttrAccRuleKind;
            ex->u.attrAccRule.prodSymb = 
              HeadProdSymbolList (currRule->prod);
            ex->u.attrAccRule.attrKey = chnKey;
            ex->u.attrAccRule.isChain = 1;
            return;
          }
	/* There is a rhs symb to access the chain TAIL from: */
        ex->exprKind = AttrAccRuleKind;
        ex->u.attrAccRule.prodSymb = symb;
        ex->u.attrAccRule.attrKey = chnKey;
        ex->u.attrAccRule.isChain = 1;
        break;
      }
    case LoopKind:
    { /* loop computation within assign (until cond do attr = iter): */
      /* add to list of loop attributes of this rule: */
      loopAttributes =
        ConsPExprList (ex->u.loop.attr, loopAttributes);
#ifdef TEST
  printf ("expr loop:  store ITER attr line %d\n",
          LineOf(*(ex->u.loop.attr->coord)));
#endif
     CheckTrafoExpr 
        (ex->u.loop.iter, 
         AttrAccType (ex->u.loop.attr) == VOIDkey);
      CheckTrafoExpr (ex->u.loop.cond, 0);
      break;
    }
    case AssignKind:
    case AttrAccSymbKind:
    case SymbTermAccKind:
    case wrongExprKind:
    case HeadAccKind:
      /* should not occur */
#ifdef TEST
  printf ("CheckTrafo wrong kind: %d\n", ex->exprKind);
#endif
    case RuleTermAccKind:
    default:;
      /* no check or transformation required */
  }
}/* CheckTrafoExpr */

/* symbol occurrences that have a GENTREE assignment are collected.
   They are checked against the insertion symbols.
*/
static ProdSymbolList gentreeAssigned;

#if defined(__cplusplus) || defined(__STDC__)
void CheckGentreeComplete (ProdSymbolList prod, ProdSymbolList assigned)
#else
void CheckGentreeComplete (prod, assigned)
  ProdSymbolList prod, assigned;
#endif
{ 
  while (prod != NULLProdSymbolList)
  { ProdSymbol sy = HeadProdSymbolList (prod);
    if (sy->kind == IsProdGenSymbol)
      { ProdSymbolList asg = assigned; 
        int found = 0;
        while (!found && asg != NULLProdSymbolList)
        { ProdSymbol s = HeadProdSymbolList (asg);
          if (s == sy) found = 1;
          asg = TailProdSymbolList (asg);
        }
        if (!found)
          message (ERROR, "GENTREE computation missing",
                   0, sy->u.s.coord);
      }
    prod = TailProdSymbolList (prod);
  }
}/* CheckGentreeComplete */

#if defined(__cplusplus) || defined(__STDC__)
void CheckLhsAttr (PExpr ex)
#else
void CheckLhsAttr (ex) PExpr ex;
#endif
{ DefTableKey ak; int idn;
  if (ex == wrongExpr || ex->exprKind == wrongExprKind) 
    return;

  if (ex->exprKind == HeadAccKind)
      { ProdSymbol symb = FindHEADSymbolOcc (currRule);
        DefTableKey chnKey = ex->u.chnKey;
        DefTableKey genRuleAttr = 
          GetEmptyHEADAttr (currCompKey, NoKey);
        if (genRuleAttr != NoKey)
        /* HEAD access substituted by generated rule attribute: */
          { ex->exprKind = RuleAttrAccKind;
            ex->u.ruleAttrAcc.attrKey = genRuleAttr;
            return;
          }
        /* HEAD access substituted by rhs chain access: */
        ex->exprKind = AttrAccRuleKind;
        ex->u.attrAccRule.prodSymb = symb;
        ex->u.attrAccRule.attrKey = chnKey;
        ex->u.attrAccRule.isChain = 1;
	return;
      }
  
  if (ex->exprKind != AttrAccRuleKind && 
      ex->exprKind != RuleAttrAccKind)
    return;

  ak = ex->exprKind == AttrAccRuleKind ?
    ex->u.attrAccRule.attrKey : ex->u.ruleAttrAcc.attrKey;

  idn = GetNameSym (ak, 0);
  if (idn != GENTREEsym)
    return;

  if (ex->exprKind == RuleAttrAccKind)
  { message (ERROR, "GENTREE may not be a RULE attribute",
             0, ex->coord);
    return;
  }

  if (currSymbOcc->kind != IsProdGenSymbol)
  { message
        (ERROR, 
         "This symbol occurrence must not have a GENTREE computation",
         0, currSymbOcc->u.s.coord);
 
    message 
        (ERROR, 
         "GENTREE may only be used at a tree insertion",
         0, ex->coord);
    return;
  }
#ifdef TEST
  printf ("GENTREE found for symbol %s:\n", 
     StringTable (GetNameSym (currSymbOcc->u.s.symbolkey, 0)));
#endif
  gentreeAssigned = ConsProdSymbolList (currSymbOcc, gentreeAssigned);
}/* CheckLhsAttr */

#if defined(__cplusplus) || defined(__STDC__)
void CheckTrafo (Binding compBind)
#else
void CheckTrafo (compBind) Binding compBind;
#endif
/* on entry
     compBind is the binding of a rule computation.
     3 global variables are set:
     currCompKey is set to the key of the current computation;
     currRule is set to the current rule;
     currSymbOcc is set to the symbol occurrence of the current computation.
     For computations of rule attributes and for 
     plain computations in rule context currSymbOcc is the
     left-hand side symbol occurrence.
   on exit
     The following  checks and transformations are made for 
     rule computations:
     - illegal use of void attributes
     - with clause in value CONSTITUENTS
     - value or void propagation for INCLUDING and CONSTITUENTS
     - distinction of a CONSTITUENTS if it is inherited to
       rules such that they differ in the SHIELD symbol
     - expansion of the RHS construct
     - check for the existence of the RHS attributes
     - substitution of abbreviations for rule names and functions
     - check of inherited terminal access
     - symbol positions for HEAD and TAIL
     - handle rule attributes
*/
{ DefTableKey compKey = KeyOf (compBind);
  PExpr compute = GetCompRepr (compKey, wrongExpr);
  if (compute == wrongExpr) return;

  currCompKey = compKey;

  switch (compute->exprKind)
  { case AssignKind: 
      /* attribute assign: */
      CheckLhsAttr (compute->u.assign.left);
      CheckTrafoExpr 
        (compute->u.assign.right, 
         AttrAccType (compute->u.assign.left) == VOIDkey);
      break;
    case LoopKind:
      /* loop computation (until cond do attr = iter): */
      /* add to list of loop attributes of this rule: */
      loopAttributes =
        ConsPExprList (compute->u.loop.attr, loopAttributes);
#ifdef TEST
  printf ("plain loop:  store ITER attr line %d\n",
          LineOf(*(compute->u.loop.attr->coord)));
#endif
     CheckTrafoExpr 
        (compute->u.loop.iter, 
         AttrAccType (compute->u.loop.attr) == VOIDkey);
      CheckTrafoExpr (compute->u.loop.cond, 0);
      break;
    case wrongExprKind:
      break;
    default:
      /* plain computation: */
#ifdef TEST
      printf ("CheckTrafo plain\n");
#endif
      CheckTrafoExpr (compute, 1);
  }
}/* CheckTrafo */


#if defined(__cplusplus) || defined(__STDC__)
int sameAttrAcc (PExpr lex, PExpr rex)
#else
int sameAttrAcc (lex, rex) PExpr lex, rex;
#endif
{ if (lex == wrongExpr || rex == wrongExpr) return 0;
  if (lex->exprKind != rex->exprKind) return 0;

  if (lex->exprKind == AttrAccRuleKind) {
#ifdef TEST
  printf ("  sameAttrAcc lines %d and %d\n",
          LineOf(*(lex->coord)), LineOf(*(rex->coord)));
#endif

    return (lex->u.attrAccRule.prodSymb == rex->u.attrAccRule.prodSymb &&
            lex->u.attrAccRule.attrKey == rex->u.attrAccRule.attrKey &&
            lex->u.attrAccRule.isChain == rex->u.attrAccRule.isChain);
  } else
  if (lex->exprKind == RuleAttrAccKind) {
    return (lex->u.ruleAttrAcc.attrKey == rex->u.ruleAttrAcc.attrKey);
  } else 
    return 0; /* chain attr or symbol context are not allowed here */
}/*sameAttrAcc  */


#if defined(__cplusplus) || defined(__STDC__)
void CheckLoopInit (DefTableKeyList allRuleComps, 
                    PExprList loopAttributes)
#else
void CheckLoopInit (allRuleComps, loopAttributes)
        DefTableKeyList allRuleComps;
        PExprList loopAttributes;
#endif
/* on entry
     allRuleComps is a list of keys of all computations of this rule.
     loopAttributes is a list of attribute accesses that occur as
     iteration attribute in a loop construct in any computation of
     this rule.
on exit:
     For every attribute in loopAttributes it is checked whether there
     is an assignment in allRuleComps. The key of that computation is 
     marked IsLoopInit
*/
{ 
#ifdef TEST
  printf ("CheckLoopInit begin\n");
#endif
  while (loopAttributes != NULLPExprList) {
    PExpr attrexpr = HeadPExprList (loopAttributes);
    DefTableKeyList comps = allRuleComps;
#ifdef TEST
  printf ("  find an assign to ITER attr line %d\n",
          LineOf(*(attrexpr->coord)));
#endif
    while (comps != NULLDefTableKeyList) {
      DefTableKey comp = HeadDefTableKeyList (comps);
      PExpr repr = GetCompRepr (comp, wrongExpr);
      if (repr != wrongExpr && repr->exprKind == AssignKind &&
          sameAttrAcc (repr->u.assign.left, attrexpr)) {
         ResetIsLoopInit (comp, 1);
#ifdef TEST
  printf ("  found an assign to ITER attr line %d\n",
          LineOf(*(repr->coord)));
#endif
         break;
      }
      comps = TailDefTableKeyList (comps);
    }
    if (comps == NULLDefTableKeyList) {
      message (ERROR, "Missing initialisation of ITER attribute",
               0, attrexpr->coord);
    }
    loopAttributes = TailPExprList (loopAttributes);
  }
#ifdef TEST
  printf ("CheckLoopInit end\n");
#endif
}/* CheckLoopInit */

void CheckRuleComps ()
/* on entry:
     All inherited computations have a representation which is
     instantiated from the original symbol computation
   on exit:
     checks and transformations are made for each rule computation
     as described by CheckTrafo;
     a list of keys is formed with the key of each computation 
     of a rule; it is associated by the property AllRuleComps
*/{
 RuleProdList rules;
  Binding rulecomp;
  /* step through all rules: */
#ifdef TEST
  printf ("CheckRuleComps started\n"); 
#endif
  rules = GrammarRules;
  while (rules != NULLRuleProdList)
  { ProdSymbolList prod;
    DefTableKey ruleKey;
    DefTableKeyList allRuleComps;
    Environment ruleScope;
    int inRootRule = 0;

    currRule = HeadRuleProdList (rules);
    ruleKey = RuleKeyOfRuleProd (currRule);
    allRuleComps = NULLDefTableKeyList;
    ruleScope = GetLowerScope (ruleKey, NoEnv);
    gentreeAssigned = NULLProdSymbolList;
    loopAttributes = NULLPExprList;
#ifdef TEST
  printf ("RULE %s:\n", 
     StringTable (GetNameSym (ruleKey, 0)));
#endif
    /* step through all computations associated to the ruleKey */
    currSymbOcc = HeadProdSymbolList (currRule->prod);
    rulecomp = DefinitionsOf(ruleScope);
    while (rulecomp != NoBinding)
    {
#ifdef TEST
  printf ("rule attr comp\n"); 
#endif
      CheckTrafo (rulecomp);
      allRuleComps = ConsDefTableKeyList (KeyOf(rulecomp), allRuleComps);
      rulecomp = NextDefinition(rulecomp);
    }
    /* step through all nonterminal occurrences of production: */
    prod = currRule->prod;
    while (prod != NULLProdSymbolList)
    { currSymbOcc = HeadProdSymbolList (prod);
      if (currSymbOcc->kind != IsProdLiteral && 
          !GetIsTerm (currSymbOcc->u.s.symbolkey, 0))
      { Environment syenv = currSymbOcc->u.s.scope;
        Environment attrenv = 
            GetAttrScope (currSymbOcc->u.s.symbolkey, NoEnv);
        Binding genattr = BindingInEnv (attrenv, GENTREEsym);
#ifdef TEST
  printf ("symbol %s:\n", 
     StringTable (GetNameSym (currSymbOcc->u.s.symbolkey, 0)));
#endif
	if (currSymbOcc->u.s.symbolkey == GrammarRoot)
		inRootRule = 1;
        /* step through all computations of this symbol occurrence */
        rulecomp = DefinitionsOf(syenv);
        while (rulecomp != NoBinding)
        { 
          CheckTrafo (rulecomp);
          allRuleComps = 
            ConsDefTableKeyList (KeyOf(rulecomp), allRuleComps);
          rulecomp = NextDefinition(rulecomp);
        }
        if (currSymbOcc->u.s.symbolpos > 0 &&
            currSymbOcc->kind != IsProdGenSymbol &&
            genattr != NoBinding) {
            /* a dummy computation for currSymbOcc.GENATTR is generated: */
            DefTableKey genCompKey = NewKey ();
            ResetIsGenTreeDummy (genCompKey, 1);
            ResetCompRepr
              (genCompKey,
               newAttrAccRule 
                  (currSymbOcc, 
                   KeyOf (genattr), 0, currSymbOcc->u.s.coord));

            allRuleComps = 
              ConsDefTableKeyList (genCompKey, allRuleComps);

        }
      }
      if (currRule->islistof) break;
      prod = TailProdSymbolList (prod);
    }
    CheckGentreeComplete (currRule->prod, gentreeAssigned);
    CheckLoopInit (allRuleComps, loopAttributes);
    ResetAllRuleComps (ruleKey, allRuleComps);
    rules = TailRuleProdList (rules);
  }
#ifdef TEST
  printf ("CheckRuleComps completed\n"); 
#endif
}/* CheckRuleComps */
~}

~O~<CompRepr.msg~>~{
"Too few terminals in rule "
"attribute with default type VOID in value context: "
"VOID attribute in value context: "
"VOID INCLUDING in value context"
"VOID CONSTITUENT(S) in value context"
"WITH clause is missing in value context"
"WITH clause is not needed in VOID context"
"Arguments of IF missing"
"IF needs else part in value context"
"Arguments of ORDER missing"
"Arguments of function call missing"
"First argument of function call must be a string"
"Unknown predefined function: "
"GENTREE attribute may only be defined"
"GENTREE computation missing"
"GENTREE may not be a RULE attribute"
"GENTREE may only be used at a tree insertion"
"This symbol occurrence must not have a GENTREE computation"
"WITH clause missing in value context"
"RHS attribute is missing for "
"RHS not allowed in LISTOF rule"
"Resulting sequence of expressions illegal in some context"
"Resulting sequence of expressions is illegal"
"Symbol inherits an illegal application of RHS or TermFct"
"Missing initialisation of ITER attribute"
"Set of remote attributes is empty"
"This empty set of remote attributes is inherited by some RULE"
"Symbol inherits a computation with an empty remote set"
~}

~O~<CompRepr.lido~>~{
~<Create representation~>
~}
