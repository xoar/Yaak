<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.29
     from name.tnf on 5 December 2013 -->

<TITLE>Name analysis according to scope rules - Predefined Identifiers</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000" BACKGROUND="gifs/bg.gif">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0" VALIGN=BOTTOM>
<TR VALIGN=BOTTOM>
<TD WIDTH="160" VALIGN=BOTTOM>
<A HREF="http://eli-project.sourceforge.net/">
<IMG SRC="gifs/elilogo.gif" BORDER=0>
</A>&nbsp;
</TD>
<TD WIDTH="25" VALIGN=BOTTOM>
<img src="gifs/empty.gif" WIDTH=25 HEIGHT=25>
</TD>
<TD ALIGN=LEFT WIDTH="475" VALIGN=BOTTOM>
<A HREF="index.html"><IMG SRC="gifs/title.png" BORDER=0></A>
</TD>
<!-- |DELETE FOR SOURCEFORGE LOGO|
<TD>
<a href="http://sourceforge.net/projects/eli-project">
<img
  src="http://sflogo.sourceforge.net/sflogo.php?group_id=70447&amp;type=13"
  width="120" height="30"
  alt="Get Eli: Translator Construction Made Easy at SourceForge.net.
    Fast, secure and Free Open Source software downloads"/>
</a>
</TD>
|DELETE FOR SOURCEFORGE LOGO| -->
</TR>
</TABLE>

<HR size=1 noshade width=785 align=left>
<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0>
<TR>
<TD VALIGN=TOP WIDTH="160">
<h4>General Information</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="index.html">Eli: Translator Construction Made Easy</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="gindex_1.html#SEC1">Global Index</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="faq_toc.html" >Frequently Asked Questions</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ee.html" >Typical Eli Usage Errors</a> </td></tr>
</table>

<h4>Tutorials</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="EliRefCard_toc.html">Quick Reference Card</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="novice_toc.html">Guide For new Eli Users</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="news_toc.html">Release Notes of Eli</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="nametutorial_toc.html">Tutorial on Name Analysis</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="typetutorial_toc.html">Tutorial on Type Analysis</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ee.html" >Typical Eli Usage Errors</a> </td></tr>
</table>

<h4>Reference Manuals</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ui_toc.html">User Interface</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="pp_toc.html">Eli products and parameters</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lidoref_toc.html">LIDO Reference Manual</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ee.html" >Typical Eli Usage Errors</a> </td></tr>
</table>

<h4>Libraries</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lib_toc.html">Eli library routines</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="modlib_toc.html">Specification Module Library</a></td></tr>
</table>

<h4>Translation Tasks</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lex_toc.html">Lexical analysis specification</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="syntax_toc.html">Syntactic Analysis Manual</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="comptrees_toc.html">Computation in Trees</a></td></tr>
</table>

<h4>Tools</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lcl_toc.html">LIGA Control Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="show_toc.html">Debugging Information for LIDO</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="gorto_toc.html">Graphical ORder TOol</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="fw_toc.html">FunnelWeb User's Manual</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ptg_toc.html">Pattern-based Text Generator</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="deftbl_toc.html">Property Definition Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="oil_toc.html">Operator Identification Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="tp_toc.html">Tree Grammar Specification Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="clp_toc.html">Command Line Processing</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="cola_toc.html">COLA Options Reference Manual</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="idem_toc.html">Generating Unparsing Code</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="mon_toc.html">Monitoring a Processor's Execution</a> </td></tr>
</table>

<h4>Administration</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="sysadmin_toc.html">System Administration Guide</a> </td></tr>
</table>

<HR WIDTH="100%">
<A HREF="mailto:eli-project-users@lists.sourceforge.net">
<IMG SRC="gifs/button_mail.gif" BORDER=0 ALIGN="left"></A>
<A HREF="index.html"><IMG SRC="gifs/home.gif" BORDER=0 ALIGN="right"></A>

</TD>
<TD VALIGN=TOP WIDTH="25"><img src="gifs/empty.gif" WIDTH=25 HEIGHT=25></TD>

<TD VALIGN=TOP WIDTH="600">
<H1>Name analysis according to scope rules</H1>
<P>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="name_2.html"><IMG SRC="gifs/prev.gif" ALT="Previous Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="name_4.html"><IMG SRC="gifs/next.gif" ALT="Next Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="name_toc.html"><IMG SRC="gifs/up.gif" ALT="Table of Contents" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT="">
<HR size=1 noshade width=600 align=left>
<H1><A NAME="SEC6" HREF="name_toc.html#SEC6">Predefined Identifiers</A></H1>
<P>
In most languages some identifiers are predefined, e.g. names for
basic types or for constants like <CODE>true</CODE> and <CODE>false</CODE>.
Their definitions are valid in any program as if they were bound in the
outermost environment. The two modules <CODE>PreDefine</CODE> and <CODE>PreDefId</CODE>
described here allow to easily introduce such predefinitions.
They require that one of the basic scope rule modules
(see  <A HREF="name_2.html#SEC2">Basic Scope Rules</A>) is used.
<P>
Both modules <CODE>PreDefine</CODE> and <CODE>PreDefId</CODE> are to be instantiated
to introduce a set of predefined entities in a name space.
<P>
The implementation of the modules use two functions which introduce a 
source identifier into the identifier table and establish a binding
for it in some environment. These functions can be used directly
for example in cases where predefinitions are to be established for
other environments than the outermost one. 
Those functions are described below.
<P>
The <CODE>PreDefine</CODE> module is instantiated by
<PRE>
   $/Name/PreDefine.gnrc +instance=NAME +referto=IDENT :inst
</PRE>
<A NAME="IDX103"></A>
<A NAME="IDX102"></A>
The optional <CODE>instance</CODE> parameter characterizes the name space in which
identifiers are to be predefined. The <CODE>instance</CODE> parameter
has to be the same as that of the basic scope rule module instance
used for that name space. Several instances of this module may address
different name spaces.
<P>
The <CODE>referto</CODE> parameter specifies
the symbol name used for identifier terminals in the grammar.
The <CODE>referto</CODE> parameter must not be omitted.
<P>
If a grammar has several identifier terminal symbols predefinitions
can be made using several instances of this module, if they belong
to different name spaces.
<A NAME="IDX104"></A>
<A NAME="IDX105"></A>
<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
<P>
The module provides two functions <CODE>NAMEPreDefine</CODE> and 
<CODE>NAMEPreDefineSym</CODE> which are called by the 
instance of the <CODE>PreDefId</CODE> module.
<CODE>NAMEPreDefineSym</CODE> inserts a string into the identifier module
to be used as an <CODE>IDENT</CODE> symbol.
<CODE>NAMEPreDefine</CODE> additionally binds that symbol to a key
in the root environment given by the global variable <CODE>NAMERootEnv</CODE>.
<P>
The predefined identifiers are to be described in a file as explained below.
The name of that file has to be given as <CODE>referto</CODE> parameter
of the instantiation of the <CODE>PreDefId</CODE> module:
<P>
<PRE>
   $/Name/PreDefId.gnrc +instance=NAME +referto=(FILENAME) :inst
</PRE>
The <CODE>instance</CODE> parameter has to be the same as that of the
<CODE>PreDefine</CODE> instance. 
If this instantiation is contained in a <CODE>.specs</CODE> file and
if the description file, say <CODE>Predef.d</CODE> is contained in the
same directory, it may read
<PRE>
   $/Name/PreDefId.gnrc +referto=(Predef.d) :inst
</PRE>
This can also be used if the <CODE>.specs</CODE> file and <CODE>Predef.d</CODE>
are contained in a <CODE>.fw</CODE> specification.
<P>
The description file contains a sequence of macro calls, one for each
predefined identifier, e.g.
<PRE>
  PreDefKey ("int", intKey)
  PreDefKey ("real", realKey)
  PreDefSym ("external", externSym)
  PreDefSymKey ("fail", failSym, failKey)
  PreDefSymKeyBind ("write", writeSym, writeKey, writeBind)
</PRE>
The sequence should not contain anything else,
because it is expanded in several contexts where different definitions
of those macros are valid.
<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<A NAME="IDX110"></A>
<A NAME="IDX111"></A>
<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<P>
Each call of one of the macros establishes a predefinition for
one identifier, and makes the result accessible via the supplied
variable names. Usually not all of those variables are needed.
Hence, the available macros differ in the combinations of
those variables. We first explain the most general macro.
The meanings of the other macros are deduced from it.
<P>
<CODE>PreDefSymKeyBind ("xxx", sym, key, bind)</CODE> 
encodes the character string <CODE>xxx</CODE> as an identifier,
stores it in the identifier table, and stores
the encoding in the <CODE>int</CODE> variable <CODE>sym</CODE>. 
<P>
Note: The string need not obey the
rules specified for the notation of <CODE>IDENT</CODE> symbols.
That facility can be used if artifacts are predefined,
which can not be referred to by a name in a program.
<P>
<CODE>key</CODE> is introduced as a PDL known key.
<P>
<CODE>key</CODE> is bound to <CODE>sym</CODE> in the environment <CODE>NAMERootEnv</CODE>.
That binding is assigned to the <CODE>Binding</CODE> variable <CODE>bind</CODE>.
The key, the identifier code, and the environment can be accessed
from the <CODE>Binding</CODE> value (<CODE>KeyOf</CODE>, <CODE>IdnOf</CODE>, <CODE>EnvOf</CODE>).
<P>
The variables <CODE>sym</CODE> and <CODE>bind</CODE> and the known key <CODE>key</CODE>
are defined, exported, and made accessible via a <CODE>.HEAD.phi</CODE>
specification. The binding is established and the assignments are
made in the initialization phase of the processor.
Hence, the results can be used only after that phase, i.e.
during all computations in the tree.
<P>
According to the above description the following macro call
<PRE>
  PreDefSymKeyBind ("write", writeSym, writeKey, writeBind)
</PRE>
creates the following variables to be defined and initialized
as described:
<PRE>
  int writeSym;
  DefTableKey writeKey;
  Binding writeBind;
</PRE>
<P>
The other macros that are provided cause a subset of the effects
described for <CODE>PreDefSymKeyBind</CODE>:
<P>
<CODE>PreDefSymKey ("xxx", sym, key)</CODE> 
As described above, except:
The binding is established but not assigned to a variable.
<P>
<CODE>PreDefKeyBind ("xxx", key, bind)</CODE> 
As described above, except:
The symbol is encoded and stored in the identifier table, but the encoding
is not assigned to a variable.
<P>
<CODE>PreDefKey ("xxx", key)</CODE> 
As described above, except:
Neither the symbol encoding nor the binding are stored in a variable.
<P>
<CODE>PreDefBind ("xxx", bind)</CODE> 
As described above, except:
The symbol encoding is not stored in a variable. The key
is created dynamically rather than as a known key.
Both, symbol encoding and the key can be accessed via the stored
<CODE>Binding</CODE> value. 
<P>
<CODE>PreDefSym ("xxx", sym)</CODE>
encodes the character string <CODE>xxx</CODE> as an identifier,
stores it in the identifier table, and stores
the encoding in the <CODE>int</CODE> variable <CODE>sym</CODE>. 
No binding is established.
<P>
The thus introduced variables and known keys may be used in
<CODE>.lido</CODE> specifications;
the known keys may be additionally used in any
specification where PDL defined entities are available.
<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<P>
The described modules are based on a C module which provides the
following two functions. They may be used directly to establish
bindings in other environments than the outermost one, for example.
In that case it is sufficient to use the module <CODE>PreDefMod.specs</CODE>.
Then the modules <CODE>PreDefine</CODE> and <CODE>PreDefId</CODE> need not be
instantiated, if the macros explained above are not used.
<P>
The two functions are:
<P>
<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<DL COMPACT>
<DT><CODE>void PreDefineSym (char *name, int code, int *sym)</CODE>
<DD>The string <CODE>name</CODE> is encoded with the given syntax <CODE>code</CODE>.
That is usually the code of the symbol used for
identifier terminals in the grammar (cf. the <CODE>referto</CODE> parameter
in the instantiation of the module <CODE>PreDefine</CODE> explained above).
<CODE>*sym</CODE> is set to the symbol index.
<A NAME="IDX118"></A>
<A NAME="IDX119"></A>
<P>
<DT><CODE>void PreDefine (char *name, int code, int *sym, Environment env, DefTableKey key,Binding *bind)</CODE>
<DD>The string <CODE>name</CODE> is encoded with the given syntax <CODE>code</CODE> 
which is bound to <CODE>key</CODE> in the given environment <CODE>env</CODE>.
<CODE>*sym</CODE> is set to the symbol index.
<CODE>*bind</CODE> is set to the created binding, if successful, 
otherwise to <CODE>NoBinding</CODE>.
</DL>
<P>
In our running example we introduce predefined names for some
basic types and for Boolean constants by the module instantiations
<PRE>
   $/Name/PreDefine.gnrc +referto=Ident :inst
   $/Name/PreDefId.gnrc +referto=(Predef.d):inst
</PRE>
The file <CODE>Predef.d</CODE> contains
<PRE>
  PreDefKey ("int", intKey)
  PreDefKey ("real", realKey)
  PreDefKey ("bool", boolKey)
  PreDefKey ("true", trueKey)
  PreDefKey ("false", falseKey)
</PRE>
Then key names like <CODE>intKey</CODE> can be used e.g. in computations
for type checking (see  <A HREF="type_toc.html">Type Analysis of Type analysis tasks</A>).
In that case it is necessary to state that <CODE>true</CODE> and <CODE>false</CODE>
are of type bool in a <CODE>.pdl</CODE> specification:
<PRE>
   trueKey -&#62; TypeOf = {boolType};
   falseKey -&#62; TypeOf = {boolType};
</PRE>
It associates the <CODE>TypeOf</CODE> property to the predefined objects.
<P>
<A NAME="IDX121"></A>
<A NAME="IDX122"></A>
<A NAME="IDX123"></A>
<A NAME="IDX120"></A>
<HR size=1 noshade width=600 align=left>
<P>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="name_2.html"><IMG SRC="gifs/prev.gif" ALT="Previous Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="name_4.html"><IMG SRC="gifs/next.gif" ALT="Next Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="name_toc.html"><IMG SRC="gifs/up.gif" ALT="Table of Contents" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT="">
<HR size=1 noshade width=600 align=left>
</TD>
</TR>
</TABLE>

</BODY></HTML>
