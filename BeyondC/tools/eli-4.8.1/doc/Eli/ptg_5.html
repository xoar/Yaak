<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.29
     from ptg.tnf on 5 December 2013 -->

<TITLE>Pattern-based Text Generator - A Complete Example</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000" BACKGROUND="gifs/bg.gif">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0" VALIGN=BOTTOM>
<TR VALIGN=BOTTOM>
<TD WIDTH="160" VALIGN=BOTTOM>
<A HREF="http://eli-project.sourceforge.net/">
<IMG SRC="gifs/elilogo.gif" BORDER=0>
</A>&nbsp;
</TD>
<TD WIDTH="25" VALIGN=BOTTOM>
<img src="gifs/empty.gif" WIDTH=25 HEIGHT=25>
</TD>
<TD ALIGN=LEFT WIDTH="475" VALIGN=BOTTOM>
<A HREF="index.html"><IMG SRC="gifs/title.png" BORDER=0></A>
</TD>
<!-- |DELETE FOR SOURCEFORGE LOGO|
<TD>
<a href="http://sourceforge.net/projects/eli-project">
<img
  src="http://sflogo.sourceforge.net/sflogo.php?group_id=70447&amp;type=13"
  width="120" height="30"
  alt="Get Eli: Translator Construction Made Easy at SourceForge.net.
    Fast, secure and Free Open Source software downloads"/>
</a>
</TD>
|DELETE FOR SOURCEFORGE LOGO| -->
</TR>
</TABLE>

<HR size=1 noshade width=785 align=left>
<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0>
<TR>
<TD VALIGN=TOP WIDTH="160">
<h4>General Information</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="index.html">Eli: Translator Construction Made Easy</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="gindex_1.html#SEC1">Global Index</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="faq_toc.html" >Frequently Asked Questions</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ee.html" >Typical Eli Usage Errors</a> </td></tr>
</table>

<h4>Tutorials</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="EliRefCard_toc.html">Quick Reference Card</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="novice_toc.html">Guide For new Eli Users</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="news_toc.html">Release Notes of Eli</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="nametutorial_toc.html">Tutorial on Name Analysis</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="typetutorial_toc.html">Tutorial on Type Analysis</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ee.html" >Typical Eli Usage Errors</a> </td></tr>
</table>

<h4>Reference Manuals</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ui_toc.html">User Interface</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="pp_toc.html">Eli products and parameters</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lidoref_toc.html">LIDO Reference Manual</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ee.html" >Typical Eli Usage Errors</a> </td></tr>
</table>

<h4>Libraries</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lib_toc.html">Eli library routines</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="modlib_toc.html">Specification Module Library</a></td></tr>
</table>

<h4>Translation Tasks</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lex_toc.html">Lexical analysis specification</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="syntax_toc.html">Syntactic Analysis Manual</a></td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="comptrees_toc.html">Computation in Trees</a></td></tr>
</table>

<h4>Tools</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="lcl_toc.html">LIGA Control Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="show_toc.html">Debugging Information for LIDO</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="gorto_toc.html">Graphical ORder TOol</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="fw_toc.html">FunnelWeb User's Manual</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="ptg_toc.html">Pattern-based Text Generator</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="deftbl_toc.html">Property Definition Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="oil_toc.html">Operator Identification Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="tp_toc.html">Tree Grammar Specification Language</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="clp_toc.html">Command Line Processing</a> </td></tr>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="cola_toc.html">COLA Options Reference Manual</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="idem_toc.html">Generating Unparsing Code</a> </td></tr>
</table>
<p>
<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="mon_toc.html">Monitoring a Processor's Execution</a> </td></tr>
</table>

<h4>Administration</h4>

<table BORDER=0 CELLSPACING=0 CELLPADDING=0>
<tr valign=top><td><img src="gifs/gelbekugel.gif" WIDTH=7 HEIGHT=7 ALT=" o"> </td><td><a href="sysadmin_toc.html">System Administration Guide</a> </td></tr>
</table>

<HR WIDTH="100%">
<A HREF="mailto:eli-project-users@lists.sourceforge.net">
<IMG SRC="gifs/button_mail.gif" BORDER=0 ALIGN="left"></A>
<A HREF="index.html"><IMG SRC="gifs/home.gif" BORDER=0 ALIGN="right"></A>

</TD>
<TD VALIGN=TOP WIDTH="25"><img src="gifs/empty.gif" WIDTH=25 HEIGHT=25></TD>

<TD VALIGN=TOP WIDTH="600">
<H1>Pattern-based Text Generator</H1>
<P>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="ptg_4.html"><IMG SRC="gifs/prev.gif" ALT="Previous Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="ptg_6.html"><IMG SRC="gifs/next.gif" ALT="Next Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="ptg_toc.html"><IMG SRC="gifs/up.gif" ALT="Table of Contents" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT="">
<HR size=1 noshade width=600 align=left>
<H1><A NAME="SEC12" HREF="ptg_toc.html#SEC12">A Complete Example</A></H1>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>
<A NAME="IDX60"></A>
<P>
In this chapter we demonstrate the use of PTG for translating a
simple assignment language into C code.
This example shows PTG techniques in the context of a complete
translator specification. It especially demonstrates how
PTG patterns are applied in LIDO specifications.
<P>
When this manual is read online, the browser's <CODE>Run</CODE> 
command can be used to obtain a copy of the complete specification 
for further experiments.
You will get a Funnelweb file <CODE>PtgEx.fw</CODE>
containing the content of this chapter (see  <A HREF="fw_toc.html">FunnelWeb</A>). 
It can be used for example to derive the specified processor by
<P>
<PRE>
PtgEx.fw :exe &#62;.
</PRE>
<P>
or to derive the set of files described below:
<P>
<PRE>
PtgEx.fw :fwGen &#62;.
</PRE>
<P>
<H2><A NAME="SEC13" HREF="ptg_toc.html#SEC13">Source Language Structure</A></H2>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<P>
Programs of this example language are sequences of assignments,
input statements, and output statements, like
<P>
<B>simple</B>[1]==
<PRE>
   input a;
   output a;
   x := a + 1;
   y := x - 5;
   output x;
   output y + x;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The values of variables and expressions are integral numbers.
There are only the binary operators <CODE>+</CODE> and <CODE>-</CODE>.
The above program is to be translated into the following C program:
<P>
<B>simple.out</B>[2]==
<PRE>
   #include &#60;stdio.h&#62;

   int a = 0, x = 0, y = 0;

   int main (void) {

   scanf ("%d", &#38;(a));
   printf ("%d\n",a);
   x = a+1;
   y = x-5;
   printf ("%d\n",x);
   printf ("%d\n",y+x);

   exit (0);
   }
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The structure of the source programs is specified by the following
concrete grammar:
<P>
<B>Program.con</B>[3]==
<PRE>
   Program:     Statement*.

   Statement:   Variable ':=' Expression ';'.
   Statement:   'input' Variable ';'.
   Statement:   'output' Expression ';'.

   Expression:  Expression Operator Operand / Operand.

   Operator:    '+' / '-'.

   Operand:     Variable.
   Operand:     IntLit.
   Variable:    Ident.
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
In the tree grammar <CODE>Expression</CODE>s and <CODE>Operand</CODE>s are
represented both by <CODE>Expression</CODE> nodes, as specified by
the type <CODE>.sym</CODE> rule:
<P>
<B>Expr.sym</B>[4]==
<PRE>
   Expression ::= Operand .
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
Identifier tokens, number literals, and comments are denoted as
in Pascal, as stated by the following type <CODE>.gla</CODE> specification:
<P>
<B>Mini.gla</B>[5]==
<PRE>
   Ident:   PASCAL_IDENTIFIER
   IntLit:  PASCAL_INTEGER
            PASCAL_COMMENT
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
<H2><A NAME="SEC14" HREF="ptg_toc.html#SEC14">Program Frame</A></H2>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>
<P>
In this section the overall structure of the target programs is
specified, the name of the output file is determined, and
its contents is produced by a PTG output function.
We first specify a pattern for target program frame:
<P>
<B>Frame.ptg</B>[6]==
<PRE>
   Frame:
      "#include &#60;stdio.h&#62;\n\n"

      $1 /* declarations */

      "\nint main (void) {\n\n"

      $2 /* statements */

      "\nexit (0);\n}\n"
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
It has two insertion points, one for variable declarations
and one for the statement sequence.
The text to be inserted is obtained from the attributes
<CODE>Program.DeclPtg</CODE> and <CODE>Program.StmtPtg</CODE> of type <CODE>PTGNode</CODE>
It is shown below how they are computed.
Here they are used as arguments of the <CODE>Frame</CODE> pattern application:
<A NAME="IDX65"></A>
<A NAME="IDX66"></A>
<P>
<B>TransProg.lido</B>[7]==
<PRE>
   ATTR DeclPtg, StmtPtg: PTGNode;

   SYMBOL Program COMPUTE
     PTGOutFile (CatStrStr(SRCFILE, ".c"),
                 PTGFrame (THIS.DeclPtg, THIS.StmtPtg));
   END;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The above call of the output function <CODE>PTGOutFile</CODE> (see
see  <A HREF="ptg_3.html#SEC7">Output Functions</A>) writes to a file which name is derived from the file
name of the source program by appending <CODE>".c"</CODE>. The concatenation
function is imported from the specification module library. See
 <A HREF="problems_2.html#SEC2">String Concatenation of Specification Module Library: Common Problems</A>, for further details on the <CODE>Strings</CODE> module.
<P>
<B>TransProg.specs</B>[8]==
<PRE>
$/Tech/Strings.specs
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The macro <CODE>SRCFILE</CODE> is obtained from the source program module, 
see  <A HREF="lib_1.html#SEC3">Text Input of Library Reference Manual</A>.
That module is included automatically into every Eli specification. So, only
it's interface has to be made known by the attribute evaluator:
<P>
<B>TransProg.head</B>[9]==
<PRE>
#include "source.h"
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
<H2><A NAME="SEC15" HREF="ptg_toc.html#SEC15">Expressions</A></H2>
<A NAME="IDX67"></A>
<A NAME="IDX68"></A>
<P>
In this section we specify the translation of expressions.
Target expressions are composed by applications of patterns
that construct the text in a bottom-up way, i.e. from the
leaves up to the complete expression.
<P>
In our simple example this translation is one-to-one as
specified by the three patterns:
<P>
<B>TransExpr.ptg</B>[10]==
<PRE>
   BinOperation: $ $ $
   Number:       $ int
   String:       $ string
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The <CODE>BinOperation</CODE> pattern composes a left operand,
an operator, and a right operand. 
The <CODE>Number</CODE> pattern just converts an integral number into
text.
The <CODE>String</CODE> pattern reproduces its argument.
It is used here for output of operators and of identifiers.
<P>
These patterns are applied in computations of <CODE>Expression</CODE>
contexts. Attributes <CODE>Ptg</CODE> of type <CODE>PTGNode</CODE> are used
for the intermediate results:
<P>
<B>TransExpr.lido</B>[11]==
<PRE>
   ATTR Ptg: PTGNode;

   RULE: Expression ::= Expression Operator Expression COMPUTE
      Expression[1].Ptg = 
         PTGBinOperation (
            Expression[2].Ptg, Operator.Ptg, Expression[3].Ptg);
   END;

   RULE: Operator ::= '+' COMPUTE
      Operator.Ptg = PTGString ("+");
   END;

   RULE: Operator ::= '-' COMPUTE
      Operator.Ptg = PTGString ("-");
   END;

   RULE: Expression ::= Variable COMPUTE
      Expression.Ptg = Variable.Ptg;
   END;

   RULE: Expression ::= IntLit COMPUTE
      Expression.Ptg = PTGNumber (IntLit);
   END;

   RULE: Variable ::= Ident COMPUTE
      Variable.Ptg = PTGString (StringTable (Ident)); 
   END;

   ATTR Sym: int;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The last two computations use values obtained from named terminal
symbols: <CODE>IntLit</CODE>
supplies an integer value to the <CODE>Number</CODE> pattern,
the token code of <CODE>Ident</CODE> is used
to access the identifier string from the <CODE>StringTable</CODE>.
The <CODE>String</CODE> pattern then reproduces the identifier.
<A NAME="IDX69"></A>
<P>
<H2><A NAME="SEC16" HREF="ptg_toc.html#SEC16">Using LIDO CHAINs</A></H2>
<A NAME="IDX70"></A>
<A NAME="IDX71"></A>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>
<P>
In this sections the translation of statement sequences is shown.
The LIDO <CODE>CHAIN</CODE> construct is used to compose a sequence
of translated statements in left-to-right order.
<P>
Assignments, input statements, and output statements are translated
by the following patterns:
<P>
<B>TransStmt.ptg</B>[12]==
<PRE>
   AssignStmt:  $1 /* lhs */ " = " $2 /* rhs */ ";\n"
   InputStmt:   "scanf (\"%d\", &#38;(" $1 /* variable */ "));\n"
   OutPutStmt:  "printf (\"%d\\n\","  $1 /* expression */ ");\n"

   Seq:         $  $
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The last pattern is used to combine two text components
(statement sequences in this case) into one (see See  <A HREF="ptg_4.html#SEC11">Output of Sequences</A>).
<P>
A <CODE>CHAIN</CODE> named <CODE>StmtChn</CODE> is defined to compose
<CODE>PTGNode</CODE>s in left-to-right order through the tree.
The <CODE>CHAIN</CODE> starts in the root context with an empty text.
The result is obtained at the end of the <CODE>CHAIN</CODE> by
<CODE>TAIL.StmtChn</CODE>:
<P>
<B>TransStChn.lido</B>[13]==
<PRE>
   CHAIN StmtChn: PTGNode;

   SYMBOL Program COMPUTE
      CHAINSTART HEAD.StmtChn = PTGNULL;
      SYNT.StmtPtg = TAIL.StmtChn;
   END;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
In each of the three statement contexts the translation
is produced by application of the corresponding pattern
and appended to the end of the <CODE>CHAIN</CODE> using the <CODE>Seq</CODE>
pattern:
<P>
<B>TransStmt.lido</B>[14]==
<PRE>
   RULE: Statement ::= Variable ':=' Expression ';' COMPUTE
      Statement.StmtChn = PTGSeq (Statement.StmtChn,
         PTGAssignStmt (Variable.Ptg, Expression.Ptg));
   END;

   RULE: Statement ::= 'input' Variable ';' COMPUTE
      Statement.StmtChn = PTGSeq (Statement.StmtChn,
         PTGInputStmt (Variable.Ptg));
   END;

   RULE: Statement ::= 'output' Expression ';' COMPUTE
      Statement.StmtChn = PTGSeq (Statement.StmtChn,
         PTGOutPutStmt (Expression.Ptg));
   END;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
<H2><A NAME="SEC17" HREF="ptg_toc.html#SEC17">Using LIDO CONSTITUENTS</A></H2>
<A NAME="IDX75"></A>
<A NAME="IDX76"></A>
<A NAME="IDX77"></A>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<P>
In this section the construction of a declarator sequence is
described using the LIDO <CODE>CONSTITUENTS</CODE> construct.
It is also shown how a list with separators is produced,
and how text is generated only once for each identifier
that occurs in the program.
<P>
The source language does not have declarations; variables
are introduced by just using them. 
Hence, we have to generate declarations in the target program,
one for each variable that occurs in the source.
<P>
A variable may occur several times, but its declaration
must be generated only once.
For that purpose each variable is identified by a key
which is associated to every occurrence of the variable.
<P>
This task is an instance of a name analysis task. We
can use the <CODE>AlgScope</CODE> module of the module library
to solve it:
<P>
<B>ScopeLib.specs</B>[15]==
<PRE>
   $/Name/AlgScope.gnrc:inst
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The computational role <CODE>IdDefScope</CODE> 
provided by that module is associated to the grammar
symbol <CODE>Variable</CODE>:
<P>
<B>Scope.lido</B>[16]==
<PRE>
   SYMBOL Variable INHERITS IdDefScope COMPUTE 
      SYNT.Sym = TERM;
   END;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The computations of that module yield an attribute <CODE>Variable.Key</CODE>.
It has the same value for each occurrence of a variable identifier.
<P>
We now associate a property <CODE>IsDeclared</CODE> to variables by a type
<CODE>.pdl</CODE> specification:
<P>
<B>Decl.pdl</B>[17]==
<PRE>
   IsDeclared: int;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
It describes a state of that variable with respect to the
translation process: A declaration is only produced if
<CODE>IsDeclared</CODE> is not yet set, and then <CODE>IsDeclared</CODE> is set.
The attribute <CODE>Variable.DeclPtg</CODE> takes the result, 
either the generated target declaration or <CODE>PTGNULL</CODE>.
<P>
<B>VarDecl.lido</B>[18]==
<PRE>
   RULE: Variable ::= Ident COMPUTE
      Variable.DeclPtg =
         IF (GetIsDeclared (Variable.Key, 0),
             PTGNULL,
             ORDER (ResetIsDeclared (Variable.Key, 1),
                    PTGDeclVariable (StringTable (Ident))));
   END;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The pattern <CODE>DeclVariable</CODE> is used here to reproduce
the variable name from the <CODE>StringTable</CODE> and to add
the initialization to it:
A single variable declarator is specified by the pattern
<P>
<B>Decl.ptg</B>[19]==
<PRE>
   DeclVariable:  $ string " = 0"
   Declaration:   "int " $ ";\n"
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The second pattern constitutes a complete declaration where
the declarator list is inserted.
<A NAME="IDX80"></A>
<P>
The declarator list is collected in the <CODE>Program</CODE> context
using a <CODE>CONSTITUENTS</CODE> construct. 
It combines the <CODE>PTGNode</CODE>
values of all <CODE>Variable.DeclPtg</CODE> attributes of the tree:
<P>
<B>ProgDecl.lido</B>[20]==
<PRE>
   SYMBOL Program COMPUTE
      SYNT.DeclPtg = 
         PTGDeclaration (
            CONSTITUENTS Variable.DeclPtg
            WITH (PTGNode, PTGCommaSeq, IDENTICAL, PTGNull));
   END;
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
The <CODE>WITH</CODE> clause of the <CODE>CONSTITUENTS</CODE> construct
specifies the type of the combined values, <CODE>PTGNode</CODE>,
and three functions which are applied to obtain the resulting
value:
<CODE>PTGNull</CODE> is the nullary predefined function producing no text.
<CODE>IDENTICAL</CODE> is a unary function predefined in LIDO; it is applied to each
<CODE>Variable.DeclPtg</CODE> attributes reproducing its value.
<CODE>PTGCommaSeq</CODE> is a pattern function that combines two
PTG texts, and separates them by a comma  if none of them is empty.
That pattern is specified using PTG's optional clause
(see See  <A HREF="ptg_4.html#SEC11">Output of Sequences</A>):
<A NAME="IDX81"></A>
<P>
<B>Comma.ptg</B>[21]==
<PRE>
   CommaSeq:  $ {", "} $
</PRE>
<PRE>
This macro is attached to a product file.
</PRE>
<P>
<HR size=1 noshade width=600 align=left>
<P>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="ptg_4.html"><IMG SRC="gifs/prev.gif" ALT="Previous Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="ptg_6.html"><IMG SRC="gifs/next.gif" ALT="Next Chapter" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT=""><A HREF="ptg_toc.html"><IMG SRC="gifs/up.gif" ALT="Table of Contents" BORDER="0"></A>
<IMG SRC="gifs/empty.gif" WIDTH=25 HEIGHT=25 ALT="">
<HR size=1 noshade width=600 align=left>
</TD>
</TR>
</TABLE>

</BODY></HTML>
